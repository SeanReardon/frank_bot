{
  "id": "unified-jorbs-implementation",
  "title": "Unified Jorbs: Script-Generating Agent Loops",
  "description": "Redesign jorbs from messaging-only to universal script-generating agents with full frank_bot capability access",
  "authors": [
    {"name": "Sean", "type": "human"},
    {"name": "Claude", "type": "model"}
  ],
  "createdAt": "2026-02-05T21:00:00Z",
  "status": "ready",
  "tags": ["jorbs", "architecture", "agent", "scripts", "refactor"],
  "content": "# Unified Jorbs Implementation\n\n## Context\n\nFrank_bot currently has two separate systems:\n1. **Jorbs** - messaging-only agents that can send SMS/Telegram/email\n2. **Scripts** - deterministic code execution with frank.* API access\n\nThis creates a gap: jorbs can't use calendar, Android phone, swarm, etc.\n\n## Goal\n\nUnify jorbs into **script-generating agent loops** where:\n- Jorb LLM receives full frank_bot context (all capabilities)\n- Jorb LLM outputs Python scripts using `frank.*` namespace\n- Scripts execute, results feed back to LLM\n- Loop until LLM declares done or pauses for approval\n- Async human interactions preserved via `await_reply` flag\n\n## Design Reference\n\nSee `prompts/unified-jorbs-design.md` for full architecture details including:\n- New JSON output format\n- Execution flow diagrams\n- Example flows (hotel booking, thermostat)\n\n## Implementation Tasks\n\n### 1. Update Jorb Session System Prompt\n\n**File:** `prompts/jorb_session_system.md`\n\nReplace the current prompt with one that:\n- Injects full frank_bot capabilities (frank.calendar, frank.sms, frank.telegram, frank.swarm, frank.android, frank.contacts, frank.time, frank.ups)\n- Expects JSON output with `script`, `await_reply`, `done`, `pause`, `result` fields\n- Includes examples of script generation\n\n**New template structure:**\n```markdown\n# Jorb Agent\n\nYou are an autonomous agent with access to frank_bot's full capabilities.\nYour job is to accomplish the task by generating Python scripts.\n\n## Available Capabilities\n\n{{CAPABILITIES_REFERENCE}}\n\n## Your Task\n\n{{TASK_PROMPT}}\n\n## Conversation History (for messaging tasks)\n\n{{MESSAGE_HISTORY}}\n\n## Script Execution History\n\n{{SCRIPT_RESULTS}}\n\n## Current Event\n\n{{CURRENT_EVENT}}\n\n## Response Format\n\nOutput valid JSON:\n{\n  \"reasoning\": \"1-2 sentences explaining your thinking\",\n  \"script\": \"Python expression using frank.* (or null if done/pausing)\",\n  \"await_reply\": true/false,\n  \"done\": true/false,\n  \"pause\": true/false,\n  \"pause_reason\": \"string if pause=true\",\n  \"result\": {} // final result if done=true\n}\n```\n\n### 2. Create Capabilities Reference Generator\n\n**File:** `services/jorb_capabilities.py` (new)\n\nGenerate the capabilities reference dynamically from FrankAPI:\n\n```python\ndef generate_capabilities_reference() -> str:\n    \"\"\"Generate markdown reference of all frank.* capabilities for jorb prompts.\"\"\"\n    # Use introspection similar to frankScriptApiLearn\n    # Return formatted markdown with method signatures and examples\n```\n\nThis ensures jorb prompts always have up-to-date capability info.\n\n### 3. Update AgentRunner to Execute Scripts\n\n**File:** `services/agent_runner.py`\n\nKey changes:\n\n1. **Parse new JSON format:**\n```python\ndef _parse_llm_response(self, response: str) -> JorbAction:\n    data = json.loads(response)\n    return JorbAction(\n        script=data.get(\"script\"),\n        await_reply=data.get(\"await_reply\", False),\n        done=data.get(\"done\", False),\n        pause=data.get(\"pause\", False),\n        pause_reason=data.get(\"pause_reason\"),\n        result=data.get(\"result\"),\n        reasoning=data.get(\"reasoning\", \"\"),\n    )\n```\n\n2. **Execute scripts via FrankAPI:**\n```python\nasync def _execute_script(self, jorb: Jorb, script: str) -> dict:\n    \"\"\"Execute a script in the FrankAPI context.\"\"\"\n    from meta.executor import Executor\n    \n    executor = Executor()\n    result = await executor.execute_inline(\n        code=f\"result = {script}\",\n        timeout=300,\n    )\n    \n    # Store result in jorb's script_results history\n    await self._storage.add_script_result(jorb.id, {\n        \"script\": script,\n        \"result\": result.result if result.success else {\"error\": result.error},\n        \"success\": result.success,\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n    })\n    \n    return result\n```\n\n3. **Handle await_reply flag:**\n```python\nasync def _process_action(self, jorb: Jorb, action: JorbAction) -> ProcessResult:\n    if action.done:\n        # Mark complete, store final result\n        return ProcessResult(complete=True, result=action.result)\n    \n    if action.pause:\n        # Pause for approval\n        return ProcessResult(paused=True, reason=action.pause_reason)\n    \n    if action.script:\n        # Execute script\n        result = await self._execute_script(jorb, action.script)\n        \n        if action.await_reply:\n            # Script sent a message, wait for human reply\n            return ProcessResult(awaiting=\"human_reply\")\n        else:\n            # Sync script, immediately invoke LLM again with result\n            return ProcessResult(continue_loop=True, script_result=result)\n    \n    return ProcessResult(no_action=True)\n```\n\n### 4. Update JorbStorage Schema\n\n**File:** `services/jorb_storage.py`\n\nAdd `script_results` field to Jorb dataclass:\n\n```python\n@dataclass\nclass Jorb:\n    # ... existing fields ...\n    script_results: list[dict] = field(default_factory=list)\n```\n\nAdd methods:\n```python\nasync def add_script_result(self, jorb_id: str, result: dict) -> None:\n    \"\"\"Append a script execution result to the jorb's history.\"\"\"\n    \nasync def get_script_results(self, jorb_id: str, limit: int = 20) -> list[dict]:\n    \"\"\"Get recent script results for a jorb.\"\"\"\n```\n\n### 5. Add frank.android Namespace to FrankAPI\n\n**File:** `meta/api.py`\n\nAdd AndroidNamespace so scripts can use phone automation:\n\n```python\nclass AndroidNamespace:\n    \"\"\"Android phone automation via task-based API.\"\"\"\n    \n    def task_do(self, goal: str, app: str = None) -> dict:\n        \"\"\"Start a phone automation task. Returns task_id immediately.\"\"\"\n        from actions.android_phone import task_do_action\n        import asyncio\n        return asyncio.get_event_loop().run_until_complete(\n            task_do_action({\"goal\": goal, \"app\": app})\n        )\n    \n    def task_get(self, task_id: str) -> dict:\n        \"\"\"Get status/result of a phone task.\"\"\"\n        from actions.android_phone import task_get_action\n        import asyncio\n        return asyncio.get_event_loop().run_until_complete(\n            task_get_action({\"task_id\": task_id})\n        )\n    \n    def task_cancel(self, task_id: str) -> dict:\n        \"\"\"Cancel a running phone task.\"\"\"\n        from actions.android_phone import task_cancel_action\n        import asyncio\n        return asyncio.get_event_loop().run_until_complete(\n            task_cancel_action({\"task_id\": task_id})\n        )\n```\n\nRegister in FrankAPI:\n```python\nclass FrankAPI:\n    def __init__(self):\n        # ... existing namespaces ...\n        self.android = AndroidNamespace()\n```\n\n### 6. Update Jorb LLM Loop Rate Limiting\n\n**File:** `services/agent_runner.py`\n\nAdd rate limiting to prevent runaway loops:\n\n```python\nMAX_ITERATIONS_PER_HOUR = 20\nMAX_ITERATIONS_PER_DAY = 100\n\nasync def _check_rate_limit(self, jorb_id: str) -> bool:\n    \"\"\"Check if jorb has exceeded iteration limits.\"\"\"\n    # Track iteration counts per jorb\n    # Return False if exceeded, True if OK\n```\n\n### 7. Handle Sync vs Async Flow\n\n**Key logic in agent_runner.py:**\n\n```python\nasync def process_jorb_event(self, jorb: Jorb, event: JorbEvent) -> None:\n    \"\"\"Main entry point for jorb processing.\"\"\"\n    \n    while True:  # Loop for sync scripts\n        # Build context with capabilities, history, current event\n        context = await self._build_context(jorb, event)\n        \n        # Call LLM\n        response = await self._call_llm(context)\n        action = self._parse_llm_response(response)\n        \n        # Process action\n        result = await self._process_action(jorb, action)\n        \n        if result.complete:\n            await self._mark_complete(jorb, action.result)\n            break\n        elif result.paused:\n            await self._mark_paused(jorb, action.pause_reason)\n            break\n        elif result.awaiting:\n            await self._mark_awaiting(jorb, result.awaiting)\n            break\n        elif result.continue_loop:\n            # Sync script completed, loop immediately with result\n            event = JorbEvent(type=\"script_result\", data=result.script_result)\n            continue\n        else:\n            # No action, done for now\n            break\n```\n\n## Testing Plan\n\n1. **Unit tests for script execution:**\n   - Test frank.calendar.events() in jorb context\n   - Test frank.telegram.send() sets await_reply correctly\n   - Test frank.android.task_do() returns task_id\n\n2. **Integration test: Simple calendar query jorb**\n   - Create jorb: \"What's on my calendar tomorrow?\"\n   - Verify LLM generates `frank.calendar.events(day='...')`\n   - Verify result returned and jorb completes\n\n3. **Integration test: Telegram conversation jorb**\n   - Create jorb: \"Ask Mom what time dinner is\"\n   - Verify message sent, jorb awaits reply\n   - Simulate reply, verify jorb processes and completes\n\n4. **Integration test: Android phone jorb**\n   - Create jorb: \"Check the thermostat\"\n   - Verify task_do called, task_get polled\n   - Verify result interpreted and jorb completes\n\n## Migration Notes\n\n- Existing jorbs continue to work (LLM can still output telegram sends)\n- New capability is additive, not breaking\n- Consider adding `jorb_version` field to distinguish old vs new format jorbs\n\n## Success Criteria\n\n1. Jorb created with \"Check thermostat\" uses Android phone and returns temperature\n2. Jorb created with \"Hotels in Paris via Magic\" sends Telegram, waits for reply, pauses for approval\n3. Jorb created with \"What restaurants did I visit in 2024\" uses swarm and returns list\n4. All existing messaging jorbs continue to work unchanged"
}
