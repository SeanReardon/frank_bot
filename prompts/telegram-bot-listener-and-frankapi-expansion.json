{
  "$schema": "https://claudia.contrived.com/schemas/prompt.schema.json",
  "id": "telegram-bot-listener-and-frankapi-expansion",
  "title": "Telegram Bot Polling Listener and FrankAPI Namespace Expansion",
  "description": "Add incoming message handling to @Seans_frank_bot via getUpdates polling, and expose all HTTP actions as FrankAPI namespaces so jorb sessions have full capability parity",
  "authors": [
    {
      "name": "Sean Reardon",
      "type": "human"
    },
    {
      "name": "Claude",
      "type": "model"
    }
  ],
  "createdAt": "2026-02-12T09:07:00Z",
  "status": "ready",
  "tags": [
    "telegram",
    "bot-api",
    "frankapi",
    "jorbs",
    "polling"
  ],
  "content": "# Telegram Bot Polling Listener and FrankAPI Namespace Expansion\n\n## Overview\n\nFrank currently listens on Telegram via a Telethon user client (personal account), but the bot account `@Seans_frank_bot` is outbound-only. This prompt adds three things:\n\n1. **Telegram Bot Polling Listener** — Make `@Seans_frank_bot` receive and process incoming messages via `getUpdates` long-polling\n2. **FrankAPI Namespace Expansion** — Expose diagnostics, health, system status, jorbs, claudia, and style actions as `frank.*` namespaces so jorb sessions can call them via scripts\n3. **Bot Reply Channel** — Ensure responses to bot-originated messages are sent back through the bot (not Telethon)\n\nThe guiding principle: anything available via the HTTP API should be callable by a jorb session through `frank.*` scripting.\n\n## Piece 1: Telegram Bot Polling Listener\n\n### Context\n\n`services/telegram_bot.py` is currently ~257 lines and purely outbound — it has `send_notification()`, `notify_unknown_sms()`, `notify_spam()`. There is no `getUpdates` call, no polling loop, no incoming message handling.\n\nThe Telethon listener in `services/telegram_jorb_router.py` gates messages through `_is_jorb_contact()` (line ~88-118), which silently drops messages from senders not in an active jorb's contacts. The bot listener must NOT have this gate — bot messages from allowlisted users go straight to the Switchboard for jorb routing.\n\n### Implementation\n\n#### New class: `TelegramBotListener` in `services/telegram_bot.py`\n\n```python\nclass TelegramBotListener:\n    def __init__(self, on_message: Callable):\n        self._token = settings.telegram_bot_token\n        self._running = False\n        self._poll_task = None\n        self._offset = 0\n        self._on_message = on_message  # callback for incoming messages\n\n    async def start_polling(self):\n        self._running = True\n        self._poll_task = asyncio.create_task(self._poll_loop())\n\n    async def stop_polling(self):\n        self._running = False\n        if self._poll_task:\n            self._poll_task.cancel()\n\n    async def _poll_loop(self):\n        while self._running:\n            updates = await self._get_updates(timeout=3)\n            for update in updates:\n                await self._process_update(update)\n\n    async def _get_updates(self, timeout=3):\n        # GET /bot{token}/getUpdates?offset={self._offset}&timeout={timeout}\n        # Parse response JSON -> list of Update objects\n        # Update self._offset = max(update_id) + 1\n        ...\n\n    async def _process_update(self, update):\n        # Extract message text, sender username, chat_id from update\n        # Check sender against telegram_allowlist\n        # If allowed: feed into MessageBuffer with channel=\"telegram_bot\"\n        # On buffer flush: create IncomingEvent(channel=\"telegram_bot\", ...) and call AgentRunner.process_incoming_message()\n        # KEY: No _is_jorb_contact() gate — bot messages go straight to Switchboard\n        ...\n```\n\nKey design decisions:\n- Use `getUpdates` long-polling (Option A) — simpler than webhooks, no public endpoint needed, follows the Telethon listener pattern\n- Poll at least every 3 seconds (`timeout=3`)\n- Use `channel=\"telegram_bot\"` on `IncomingEvent` to distinguish from `\"telegram\"` (Telethon personal account)\n- Skip the `_is_jorb_contact()` gate entirely — bot messages from allowlisted senders go straight to Switchboard\n- Use `MessageBuffer` for debouncing, same pattern as `telegram_jorb_router.py`\n\n#### Wire into lifecycle in `services/background_loop.py`\n\nIn `BackgroundLoopService.start()`, after initializing the Telethon router:\n```python\nself._bot_listener = TelegramBotListener(on_message=_on_bot_message_flush)\nawait self._bot_listener.start_polling()\n```\n\nIn `BackgroundLoopService.stop()`:\n```python\nawait self._bot_listener.stop_polling()\n```\n\nConsider creating a `services/telegram_bot_router.py` with the flush callback and buffer setup, mirroring `telegram_jorb_router.py` pattern but without the jorb contact gate.\n\n#### Add bot reply channel in `services/agent_runner.py`\n\nIn `_send_message()`, add a branch for `channel == \"telegram_bot\"`:\n```python\nelif channel == \"telegram_bot\":\n    from services.telegram_bot import TelegramBotService  # or however the bot send is exposed\n    result = await bot_service.send_message(chat_id, content)\n    return result.success\n```\n\nThis ensures responses to bot-originated messages go back through the bot, not Telethon.\n\n### Switchboard Behavior\n\nWhen the Switchboard sees `channel=\"telegram_bot\"`, it works exactly the same as `\"telegram\"`. No special handling needed. The existing `_process_with_switchboard` in `agent_runner.py` will:\n- If jorb matched → route to it\n- If `might_be_new_jorb` + trusted sender → create catch-up jorb (line ~1333) which will naturally ask for context (\"hey, can you give me a quick reminder what this is about?\")\n- If spam → ignore\n\nThis matches the desired behavior: when someone on the allowlist says something unfamiliar, Frank should be comfortable asking for a quick reminder rather than silently dropping the message.\n\n## Piece 2: FrankAPI Namespace Expansion\n\n### Context\n\n`meta/api.py` currently exposes 8 namespaces: calendar, contacts, sms, swarm, ups, time, telegram, android. The HTTP surface has ~94 endpoints, but many are not accessible to jorb sessions via scripts. The gap is significant.\n\n### New Namespaces to Add\n\nFollow the exact existing pattern: sync wrapper classes using `_run_async()` to call async action functions.\n\n#### `DiagnosticsNamespace`\n```python\nclass DiagnosticsNamespace:\n    \"\"\"System diagnostics and health checks.\"\"\"\n\n    def full(self) -> dict:\n        \"\"\"Comprehensive diagnostics for all subsystems.\"\"\"\n        from actions.diagnostics import get_diagnostics_action\n        return _run_async(get_diagnostics_action())\n\n    def health(self) -> dict:\n        \"\"\"Quick health check.\"\"\"\n        from actions.diagnostics import health_action\n        return _run_async(health_action())\n```\nUsage: `frank.diagnostics.full()`, `frank.diagnostics.health()`\n\n#### `SystemNamespace`\n```python\nclass SystemNamespace:\n    \"\"\"System and server status.\"\"\"\n\n    def status(self) -> dict:\n        \"\"\"Orchestration machinery status (switchboard, agent, router, buffer).\"\"\"\n        from actions.system_status import get_system_status_action\n        return _run_async(get_system_status_action())\n\n    def server(self) -> dict:\n        \"\"\"Server uptime info.\"\"\"\n        from actions.system import get_server_status_action\n        return _run_async(get_server_status_action())\n\n    def hello(self, name: str = \"world\") -> dict:\n        from actions.system import hello_world_action\n        return _run_async(hello_world_action({\"name\": name}))\n```\nUsage: `frank.system.status()`, `frank.system.server()`\n\n#### `JorbsNamespace`\n```python\nclass JorbsNamespace:\n    \"\"\"Jorb management operations.\"\"\"\n\n    def list(self, *, status: str = \"open\") -> dict:\n        from actions.jorbs import list_jorbs_action\n        return _run_async(list_jorbs_action({\"status\": status}))\n\n    def get(self, jorb_id: str, *, include_messages: bool = False, message_limit: int = 50) -> dict:\n        from actions.jorbs import get_jorb_action\n        return _run_async(get_jorb_action({\"jorb_id\": jorb_id, \"include_messages\": include_messages, \"message_limit\": message_limit}))\n\n    def create(self, name: str, plan: str, *, contacts=None, personality=\"default\", start_immediately=True) -> dict:\n        from actions.jorbs import create_jorb_action\n        return _run_async(create_jorb_action({\"name\": name, \"plan\": plan, \"contacts\": contacts or [], \"personality\": personality, \"start_immediately\": start_immediately}))\n\n    def approve(self, jorb_id: str, decision: str) -> dict:\n        from actions.jorbs import approve_jorb_action\n        return _run_async(approve_jorb_action({\"jorb_id\": jorb_id, \"decision\": decision}))\n\n    def cancel(self, jorb_id: str, *, reason: str = \"\") -> dict:\n        from actions.jorbs import cancel_jorb_action\n        return _run_async(cancel_jorb_action({\"jorb_id\": jorb_id, \"reason\": reason}))\n\n    def stats(self, *, status: str = \"all\") -> dict:\n        from actions.jorbs import get_jorbs_stats_action\n        return _run_async(get_jorbs_stats_action({\"status\": status}))\n\n    def brief(self, *, hours: int = 24) -> dict:\n        from actions.jorbs import brief_me_action\n        return _run_async(brief_me_action({\"hours\": hours}))\n\n    def messages(self, jorb_id: str, *, limit: int = 50, offset: int = 0) -> dict:\n        from actions.jorbs import get_jorb_messages_action\n        return _run_async(get_jorb_messages_action({\"jorb_id\": jorb_id, \"limit\": limit, \"offset\": offset}))\n```\nUsage: `frank.jorbs.list()`, `frank.jorbs.create(name=..., plan=...)`, `frank.jorbs.brief()`\n\n#### `ClaudiaNamespace`\n```python\nclass ClaudiaNamespace:\n    \"\"\"Claudia (Claude Code agent) operations.\"\"\"\n\n    def repos(self) -> dict:\n        from actions.claudia import list_claudia_repos_action\n        return _run_async(list_claudia_repos_action())\n\n    def chat_create(self, repo_name: str, title: str, *, message: str | None = None) -> dict:\n        from actions.claudia import create_claudia_chat_action\n        return _run_async(create_claudia_chat_action({\"repo_name\": repo_name, \"title\": title, \"message\": message}))\n\n    def chat_get(self, repo_id: str, chat_id: str) -> dict:\n        from actions.claudia import get_claudia_chat_action\n        return _run_async(get_claudia_chat_action({\"repo_id\": repo_id, \"chat_id\": chat_id}))\n\n    def chat_send(self, repo_id: str, chat_id: str, message: str) -> dict:\n        from actions.claudia import send_claudia_message_action\n        return _run_async(send_claudia_message_action({\"repo_id\": repo_id, \"chat_id\": chat_id, \"message\": message}))\n\n    def chat_end(self, repo_id: str, chat_id: str) -> dict:\n        from actions.claudia import end_claudia_chat_action\n        return _run_async(end_claudia_chat_action({\"repo_id\": repo_id, \"chat_id\": chat_id}))\n\n    def prompts(self, repo_id: str) -> dict:\n        from actions.claudia import list_claudia_prompts_action\n        return _run_async(list_claudia_prompts_action({\"repo_id\": repo_id}))\n\n    def prompt_get(self, repo_id: str, prompt_id: str) -> dict:\n        from actions.claudia import get_claudia_prompt_action\n        return _run_async(get_claudia_prompt_action({\"repo_id\": repo_id, \"prompt_id\": prompt_id}))\n\n    def prompt_execute(self, repo_id: str, prompt_id: str) -> dict:\n        from actions.claudia import execute_claudia_prompt_action\n        return _run_async(execute_claudia_prompt_action({\"repo_id\": repo_id, \"prompt_id\": prompt_id}))\n\n    def queue(self, repo_id: str) -> dict:\n        from actions.claudia import get_claudia_queue_action\n        return _run_async(get_claudia_queue_action({\"repo_id\": repo_id}))\n\n    def executions(self, *, repo_id: str | None = None, status: str | None = None, limit: int = 50) -> dict:\n        from actions.claudia import list_claudia_executions_action\n        return _run_async(list_claudia_executions_action({\"repo_id\": repo_id, \"status\": status, \"limit\": limit}))\n\n    def execution_get(self, execution_id: str) -> dict:\n        from actions.claudia import get_claudia_execution_action\n        return _run_async(get_claudia_execution_action({\"execution_id\": execution_id}))\n```\nUsage: `frank.claudia.repos()`, `frank.claudia.chat_create(\"frank_bot\", \"Fix the bug\", message=\"...\")`\n\n#### `StyleNamespace`\n```python\nclass StyleNamespace:\n    \"\"\"Style capture and generation.\"\"\"\n\n    def generate(self, *, chat_id: str | None = None, dry_run: bool = False, before_date: str | None = None) -> dict:\n        from actions.style_capture import generate_sean_md_action\n        return _run_async(generate_sean_md_action({\"chat_id\": chat_id, \"dry_run\": dry_run, \"before_date\": before_date}))\n```\nUsage: `frank.style.generate(dry_run=True)`\n\n### Wire into `FrankAPI.__init__()`\n\nAdd to `__init__`:\n```python\nself._diagnostics = DiagnosticsNamespace()\nself._system = SystemNamespace()\nself._jorbs = JorbsNamespace()\nself._claudia = ClaudiaNamespace()\nself._style = StyleNamespace()\n```\n\nAdd corresponding `@property` methods:\n```python\n@property\ndef diagnostics(self) -> DiagnosticsNamespace: return self._diagnostics\n@property\ndef system(self) -> SystemNamespace: return self._system\n@property\ndef jorbs(self) -> JorbsNamespace: return self._jorbs\n@property\ndef claudia(self) -> ClaudiaNamespace: return self._claudia\n@property\ndef style(self) -> StyleNamespace: return self._style\n```\n\n### Update `actions/scripts.py` `api_learn_action`\n\nAdd entries for the new namespaces in the `namespaces` dict so jorb sessions know about the new capabilities when they call `frank.learn()` or the API learn endpoint.\n\n## Piece 3: Verification of Switchboard Catch-Up Behavior\n\nThe Switchboard's existing behavior in `agent_runner.py` (line ~1317-1341) already handles the \"no match\" case correctly for trusted senders:\n- `might_be_new_jorb: true` + trusted sender → creates a catch-up jorb that will ask for context\n\nVerify that this works end-to-end with the new `telegram_bot` channel. The Switchboard prompt in `switchboard_system.md` may need a small tweak to be more comfortable saying \"I don't recognize this — might be new\" rather than trying to force-match.\n\n## Files to Create/Modify\n\n| File | Change |\n|------|--------|\n| `services/telegram_bot.py` | Add `TelegramBotListener` class with `getUpdates` polling loop |\n| `services/telegram_bot_router.py` (new, optional) | Flush callback + buffer setup, mirroring `telegram_jorb_router.py` without jorb contact gate |\n| `services/background_loop.py` | Wire bot listener start/stop into lifecycle |\n| `services/agent_runner.py` | Add `telegram_bot` channel to `_send_message()` for outbound replies |\n| `meta/api.py` | Add 5 new namespace classes (Diagnostics, System, Jorbs, Claudia, Style) + wire into FrankAPI |\n| `actions/scripts.py` | Update `api_learn_action` to document new namespaces |\n\n## Testing\n\n1. **FrankAPI namespaces**: Write unit tests that verify each new namespace method calls the correct action function. Follow the pattern in existing tests.\n2. **Bot listener**: Test `TelegramBotListener._process_update()` with mock updates. Verify allowlist check, buffer integration, and that no jorb-contact gate is applied.\n3. **Bot reply channel**: Test that `_send_message(channel=\"telegram_bot\", ...)` routes through the bot API, not Telethon.\n4. **Integration**: Verify end-to-end that sending \"hi frank, what are your diagnostics?\" to `@Seans_frank_bot` on Telegram results in Frank creating a jorb (or matching an existing one), running `frank.diagnostics.full()`, and replying with the results.\n\n## Success Criteria\n\n1. `@Seans_frank_bot` receives and processes incoming Telegram messages via `getUpdates` polling\n2. Messages from allowlisted users go straight to the Switchboard (no jorb-contact gate)\n3. Unmatched messages from trusted senders create catch-up jorbs that ask for context\n4. Jorb sessions can call `frank.diagnostics.full()`, `frank.diagnostics.health()`, `frank.system.status()`, `frank.jorbs.list()`, `frank.claudia.repos()`, `frank.style.generate()`, and all other new namespace methods\n5. `api_learn_action` documents all new namespaces\n6. Bot replies go back through the bot API, not Telethon\n7. Existing Telethon listener continues working unchanged",
  "executions": []
}
