{
  "$schema": "https://claudia.contrived.com/schemas/prompt.schema.json",
  "id": "sms-receive-and-mms",
  "title": "Inbound SMS/MMS Handling with Jorbs Integration",
  "description": "Add webhook endpoint to receive SMS/MMS, store messages as JSON files, integrate with jorbs system, and notify via Telegram bot for unknown senders",
  "authors": [
    { "name": "Sean", "type": "human" },
    { "name": "Claude", "type": "model" }
  ],
  "createdAt": "2026-01-29T00:00:00Z",
  "status": "ready",
  "tags": ["sms", "mms", "telnyx", "webhook", "jorbs", "telegram-bot"],
  "blockedBy": null,
  "content": "# Inbound SMS/MMS Handling with Jorbs Integration\n\n## Overview\n\nFrank_bot currently can SEND SMS via Telnyx but cannot RECEIVE. This prompt adds:\n\n1. Webhook endpoint to receive inbound SMS/MMS from Telnyx\n2. Storage of all messages (inbound AND outbound) as JSON files\n3. Contact name enrichment via Google Contacts reverse lookup\n4. Integration with the jorbs system (route to LLM for context-aware replies)\n5. Telegram Bot notifications for unknown/spam senders\n6. ChatGPT action to read recent SMS messages\n\n## Background\n\n### Shared Phone Number\n\nThe Telnyx phone number `+12148170664` is currently used by `let-food-into-civic` for:\n- **Voice**: Receives calls from apartment call box, plays DTMF to unlock gate\n- **SMS**: Handles STOP/HELP opt-in/opt-out compliance (BEING MOVED TO FRANK_BOT)\n\nAfter this change:\n- **Voice**: Still handled by let-food-into-civic (unchanged)\n- **SMS**: Handled by frank_bot (webhook URL changed in Telnyx portal)\n\n### Telnyx Portal (ALREADY CONFIGURED)\n\nThe Telnyx messaging profile webhook has been updated:\n- **Inbound webhook**: `https://frank-bot-api.contrived.com/webhook/sms` âœ…\n- **Outbound webhook**: Not configured (delivery receipts not needed)\n\n## Architecture\n\n### SMS/MMS Storage\n\n**Directory structure:**\n```\n./data/sms/+12148170664/                    # Local Telnyx number\n  2026-01-29T18-45-32-Mom.json              # Known contact\n  2026-01-29T18-45-32-Mom-attachment-1.jpg  # MMS attachment (if any)\n  2026-01-29T19-02-15-+15551234567.json     # Unknown contact (use phone as name)\n```\n\n**File naming:**\n- Pattern: `{ISO8601-timestamp}-{contact-name-or-phone}.json`\n- Timestamp uses `-` instead of `:` for filesystem compatibility\n- Contact name: Use Google Contacts display name if found, otherwise phone number with `+`\n- Attachments: Same base name with `-attachment-{n}.{ext}` suffix\n\n### SMS Message Schema\n\nCreate `schemas/sms.schema.json`:\n\n```json\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://frank-bot.contrived.com/schemas/sms.schema.json\",\n  \"title\": \"SMS/MMS Message\",\n  \"description\": \"Stored SMS or MMS message (inbound or outbound)\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"timestamp\", \"direction\", \"localNumber\", \"remoteNumber\", \"content\"],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"description\": \"Unique message ID (sms_{timestamp}_{remoteNumber})\",\n      \"pattern\": \"^sms_[0-9]+_\\\\+[0-9]+$\"\n    },\n    \"timestamp\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"ISO 8601 timestamp when message was sent/received\"\n    },\n    \"direction\": {\n      \"type\": \"string\",\n      \"enum\": [\"inbound\", \"outbound\"],\n      \"description\": \"Whether message was received or sent\"\n    },\n    \"localNumber\": {\n      \"type\": \"string\",\n      \"description\": \"Our Telnyx number (E.164 format)\",\n      \"pattern\": \"^\\\\+[0-9]+$\"\n    },\n    \"remoteNumber\": {\n      \"type\": \"string\",\n      \"description\": \"The other party's phone number (E.164 format)\",\n      \"pattern\": \"^\\\\+[0-9]+$\"\n    },\n    \"contact\": {\n      \"type\": \"object\",\n      \"description\": \"Resolved contact info (null if unknown)\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"description\": \"Display name from Google Contacts\"\n        },\n        \"googleContactId\": {\n          \"type\": \"string\",\n          \"description\": \"Google People API resource name (e.g., people/c1234567890)\"\n        }\n      },\n      \"required\": [\"name\"]\n    },\n    \"content\": {\n      \"type\": \"string\",\n      \"description\": \"Message text content\"\n    },\n    \"attachments\": {\n      \"type\": \"array\",\n      \"description\": \"MMS attachments (if any)\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"filename\", \"contentType\", \"size\"],\n        \"properties\": {\n          \"filename\": {\n            \"type\": \"string\",\n            \"description\": \"Local filename where attachment is stored\"\n          },\n          \"contentType\": {\n            \"type\": \"string\",\n            \"description\": \"MIME type (e.g., image/jpeg)\"\n          },\n          \"size\": {\n            \"type\": \"integer\",\n            \"description\": \"File size in bytes\"\n          },\n          \"originalUrl\": {\n            \"type\": \"string\",\n            \"description\": \"Original Telnyx media URL (for reference)\"\n          }\n        }\n      }\n    },\n    \"telnyxMessageId\": {\n      \"type\": \"string\",\n      \"description\": \"Telnyx message ID for tracking\"\n    },\n    \"processed\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether message has been processed by jorbs system\",\n      \"default\": false\n    },\n    \"jorbId\": {\n      \"type\": \"string\",\n      \"description\": \"Associated jorb ID (if routed to a jorb)\",\n      \"pattern\": \"^jorb_[0-9]+$\"\n    },\n    \"replyToMessageId\": {\n      \"type\": \"string\",\n      \"description\": \"ID of message this is replying to (for threading)\"\n    },\n    \"classification\": {\n      \"type\": \"string\",\n      \"enum\": [\"jorb\", \"spam\", \"unknown\", \"compliance\"],\n      \"description\": \"How the message was classified\"\n    }\n  }\n}\n```\n\n## Implementation\n\n### 1. Webhook Endpoint\n\nAdd to `server/routes.py`:\n\n```python\n# SMS webhook (no API key - Telnyx needs to POST to it)\nRoute(\"/webhook/sms\", sms_webhook_handler, methods=[\"POST\"]),\n```\n\nCreate handler in `server/sms_webhook.py`:\n\n```python\nasync def sms_webhook_handler(request: Request) -> JSONResponse:\n    \"\"\"\n    Webhook endpoint for Telnyx inbound SMS/MMS.\n    \n    Telnyx sends webhooks for ALL message events:\n    - message.received (inbound) - process these\n    - message.sent (outbound confirmation) - skip\n    - message.finalized (delivery receipt) - skip\n    \"\"\"\n    data = await request.json()\n    \n    # Extract event info\n    event_type = data.get(\"data\", {}).get(\"event_type\", \"\")\n    direction = data.get(\"data\", {}).get(\"payload\", {}).get(\"direction\", \"\")\n    \n    # Skip non-inbound messages\n    if direction == \"outbound\" or event_type != \"message.received\":\n        return JSONResponse({\"status\": \"skipped\", \"reason\": f\"{direction}/{event_type}\"})\n    \n    # Process inbound message\n    await process_inbound_sms(data)\n    \n    return JSONResponse({\"status\": \"processed\"})\n```\n\n### 2. SMS Storage Service\n\nCreate `services/sms_storage.py`:\n\n```python\nclass SMSStorage:\n    def __init__(self, data_dir: Path = Path(\"./data/sms\")):\n        self.data_dir = data_dir\n    \n    async def store_message(self, message: SMSMessage) -> Path:\n        \"\"\"Store an SMS/MMS message and return the file path.\"\"\"\n        # Create directory for local number\n        number_dir = self.data_dir / message.local_number\n        number_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Build filename\n        timestamp_str = message.timestamp.strftime(\"%Y-%m-%dT%H-%M-%S\")\n        contact_part = message.contact.name if message.contact else message.remote_number\n        # Sanitize for filesystem\n        contact_part = re.sub(r'[<>:\"/\\\\|?*]', '_', contact_part)\n        \n        filename = f\"{timestamp_str}-{contact_part}.json\"\n        filepath = number_dir / filename\n        \n        # Store attachments if MMS\n        if message.attachments:\n            for i, attachment in enumerate(message.attachments, 1):\n                ext = mimetypes.guess_extension(attachment.content_type) or '.bin'\n                att_filename = f\"{timestamp_str}-{contact_part}-attachment-{i}{ext}\"\n                att_path = number_dir / att_filename\n                # Download and save attachment\n                await self._download_attachment(attachment.original_url, att_path)\n                attachment.filename = att_filename\n        \n        # Write JSON\n        async with aiofiles.open(filepath, 'w') as f:\n            await f.write(message.model_dump_json(indent=2))\n        \n        return filepath\n    \n    async def get_recent_messages(\n        self,\n        local_number: str | None = None,\n        remote_number: str | None = None,\n        contact_name: str | None = None,\n        limit: int = 50,\n    ) -> list[SMSMessage]:\n        \"\"\"Get recent messages, optionally filtered.\"\"\"\n        # Implementation: glob files, parse JSON, filter, sort by timestamp\n        ...\n```\n\n### 3. Contact Reverse Lookup\n\nCreate `services/contact_lookup.py`:\n\n```python\nclass ContactLookup:\n    \"\"\"Reverse lookup phone number to Google Contact.\"\"\"\n    \n    def __init__(self):\n        self._cache: dict[str, Contact | None] = {}\n    \n    async def lookup(self, phone_number: str) -> Contact | None:\n        \"\"\"\n        Look up a phone number in Google Contacts.\n        \n        Returns Contact with name and googleContactId, or None if not found.\n        \"\"\"\n        # Check cache\n        if phone_number in self._cache:\n            return self._cache[phone_number]\n        \n        # Normalize phone number for comparison\n        normalized = normalize_phone(phone_number)\n        \n        # Search contacts\n        contacts_service = GoogleContactsService()\n        # Search by phone number\n        results = contacts_service.search_contacts(normalized)\n        \n        # Find contact with matching phone\n        for contact in results:\n            for phone in contact.get(\"phoneNumbers\", []):\n                if normalize_phone(phone.get(\"value\", \"\")) == normalized:\n                    result = Contact(\n                        name=contact.get(\"names\", [{}])[0].get(\"displayName\", \"Unknown\"),\n                        google_contact_id=contact.get(\"resourceName\")\n                    )\n                    self._cache[phone_number] = result\n                    return result\n        \n        self._cache[phone_number] = None\n        return None\n```\n\n### 4. STOP/HELP Compliance\n\nHandle compliance commands ONLY for unknown contacts:\n\n```python\nasync def process_inbound_sms(data: dict):\n    # Parse message\n    payload = data[\"data\"][\"payload\"]\n    from_number = extract_phone(payload.get(\"from\", {}))\n    text = payload.get(\"text\", \"\").strip().upper()\n    \n    # Reverse lookup contact\n    contact = await contact_lookup.lookup(from_number)\n    \n    # Handle compliance ONLY for unknown contacts\n    if contact is None:\n        if text == \"STOP\":\n            await handle_opt_out(from_number)\n            return\n        elif text == \"HELP\":\n            await send_help_message(from_number)\n            return\n        elif text in [\"START\", \"YES\", \"OPTIN\", \"SUBSCRIBE\"]:\n            await handle_opt_in(from_number)\n            return\n    \n    # For known contacts, skip compliance and proceed to jorbs routing\n    # ... continue with normal processing\n```\n\n### 5. Telegram Bot Notifications\n\nCreate `services/telegram_bot.py`:\n\n```python\n\"\"\"\nTelegram Bot for notifications (separate from Telethon user client).\n\nUses the Bot API (not Telethon) for simple notifications.\nBot created via BotFather, token stored in Vault.\n\"\"\"\n\nimport httpx\n\nclass TelegramBot:\n    def __init__(self, token: str, chat_id: str):\n        self.token = token\n        self.chat_id = chat_id\n        self.api_base = f\"https://api.telegram.org/bot{token}\"\n    \n    async def send_notification(self, text: str, parse_mode: str = \"HTML\") -> bool:\n        \"\"\"Send a notification message.\"\"\"\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f\"{self.api_base}/sendMessage\",\n                json={\n                    \"chat_id\": self.chat_id,\n                    \"text\": text,\n                    \"parse_mode\": parse_mode,\n                }\n            )\n            return response.status_code == 200\n    \n    async def notify_unknown_sms(\n        self,\n        from_number: str,\n        message: str,\n        attachments: list[str] | None = None,\n    ):\n        \"\"\"Notify about SMS from unknown sender.\"\"\"\n        text = (\n            \"ðŸ“± <b>New SMS from unknown number</b>\\n\\n\"\n            f\"<b>From:</b> {from_number}\\n\"\n            f\"<b>Message:</b> {message[:500]}\\n\"\n        )\n        if attachments:\n            text += f\"\\nðŸ“Ž {len(attachments)} attachment(s)\"\n        \n        await self.send_notification(text)\n    \n    async def notify_spam(\n        self,\n        from_number: str,\n        message: str,\n        reason: str,\n    ):\n        \"\"\"Notify about suspected spam (optional, could be disabled).\"\"\"\n        text = (\n            \"ðŸš« <b>Suspected spam SMS</b>\\n\\n\"\n            f\"<b>From:</b> {from_number}\\n\"\n            f\"<b>Reason:</b> {reason}\\n\"\n            f\"<b>Message:</b> {message[:200]}...\"\n        )\n        await self.send_notification(text)\n```\n\n### 6. Vault Secrets for Telegram Bot\n\nAdd to `terraform/vault/variables.tf`:\n\n```hcl\n# Telegram Bot (for notifications)\nvariable \"telegram_bot_token\" {\n  type        = string\n  description = \"Telegram Bot token from BotFather\"\n  sensitive   = true\n}\n\nvariable \"telegram_bot_chat_id\" {\n  type        = string\n  description = \"Chat ID for bot notifications (Sean's user ID)\"\n  sensitive   = true\n}\n```\n\nAdd to `terraform/vault/secrets.tf`:\n\n```hcl\n# Telegram Bot credentials (for notifications)\nresource \"vault_kv_secret_v2\" \"telegram_bot\" {\n  mount = \"secret\"\n  name  = \"frank-bot/telegram-bot\"\n  data_json = jsonencode({\n    token   = var.telegram_bot_token\n    chat_id = var.telegram_bot_chat_id\n  })\n\n  lifecycle {\n    ignore_changes = [data_json]\n  }\n}\n```\n\nAdd to `services/vault_client.py`:\n\n```python\ndef get_telegram_bot_credentials() -> dict[str, str] | None:\n    \"\"\"Get Telegram Bot credentials from Vault.\"\"\"\n    return get_secret(\"frank-bot/telegram-bot\")\n```\n\n### 7. Inbound Message Processing Flow\n\n```python\nasync def process_inbound_sms(data: dict):\n    \"\"\"Full processing pipeline for inbound SMS/MMS.\"\"\"\n    \n    # 1. Parse Telnyx payload\n    payload = data[\"data\"][\"payload\"]\n    from_number = extract_phone(payload.get(\"from\", {}))\n    to_number = extract_phone(payload.get(\"to\", [{}])[0])\n    text = payload.get(\"text\", \"\")\n    media = payload.get(\"media\", [])  # MMS attachments\n    telnyx_id = data[\"data\"].get(\"id\")\n    \n    # 2. Reverse lookup contact\n    contact = await contact_lookup.lookup(from_number)\n    \n    # 3. Handle compliance for unknown contacts\n    if contact is None:\n        upper_text = text.strip().upper()\n        if upper_text == \"STOP\":\n            await handle_opt_out(from_number)\n            return\n        elif upper_text == \"HELP\":\n            await send_help_message(from_number)\n            return\n        elif upper_text in [\"START\", \"YES\", \"OPTIN\", \"SUBSCRIBE\"]:\n            await handle_opt_in(from_number)\n            return\n    \n    # 4. Build message object\n    message = SMSMessage(\n        id=f\"sms_{int(time.time())}_{from_number}\",\n        timestamp=datetime.now(timezone.utc),\n        direction=\"inbound\",\n        local_number=to_number,\n        remote_number=from_number,\n        contact=contact,\n        content=text,\n        attachments=[...],  # Parse media array\n        telnyx_message_id=telnyx_id,\n        processed=False,\n    )\n    \n    # 5. Store immediately\n    filepath = await sms_storage.store_message(message)\n    logger.info(f\"Stored inbound SMS: {filepath}\")\n    \n    # 6. Add to debounce buffer\n    await message_buffer.add(\n        channel=\"sms\",\n        sender=from_number,\n        message=message,\n    )\n    # After debounce expires (30s), route to LLM with:\n    # - All active jorbs\n    # - Contact info (name if known!)\n    # - Message content\n```\n\n### 8. Update Outbound SMS to Also Store\n\nModify `services/telnyx_sms.py` `send_sms()` to also write to storage:\n\n```python\ndef send_sms(self, to_number: str, message: str, ...) -> SMSResult:\n    # ... existing send logic ...\n    \n    if result.success:\n        # Also store the outbound message\n        contact = await contact_lookup.lookup(to_number)\n        outbound_msg = SMSMessage(\n            id=f\"sms_{int(time.time())}_{to_number}\",\n            timestamp=datetime.now(timezone.utc),\n            direction=\"outbound\",\n            local_number=self._from_number,\n            remote_number=to_number,\n            contact=contact,\n            content=message,\n            telnyx_message_id=result.message_id,\n            processed=True,  # Outbound is already \"processed\"\n        )\n        await sms_storage.store_message(outbound_msg)\n    \n    return result\n```\n\n### 9. ChatGPT Action: Get SMS Messages\n\nAdd to `actions/sms.py`:\n\n```python\nasync def get_sms_messages_action(arguments: dict | None = None) -> dict:\n    \"\"\"\n    Get recent SMS messages for diagnostics.\n    \n    Args:\n        limit: Number of messages (default 50, max 100)\n        contact: Filter by contact name (fuzzy match)\n        phone: Filter by phone number\n        direction: Filter by 'inbound' or 'outbound'\n    \"\"\"\n    args = arguments or {}\n    limit = min(int(args.get(\"limit\", 50)), 100)\n    contact_filter = args.get(\"contact\")\n    phone_filter = args.get(\"phone\")\n    direction_filter = args.get(\"direction\")\n    \n    storage = SMSStorage()\n    messages = await storage.get_recent_messages(\n        contact_name=contact_filter,\n        remote_number=phone_filter,\n        limit=limit,\n    )\n    \n    if direction_filter:\n        messages = [m for m in messages if m.direction == direction_filter]\n    \n    return {\n        \"count\": len(messages),\n        \"messages\": [\n            {\n                \"timestamp\": m.timestamp.isoformat(),\n                \"direction\": m.direction,\n                \"contact\": m.contact.name if m.contact else None,\n                \"phone\": m.remote_number,\n                \"preview\": m.content[:100] + (\"...\" if len(m.content) > 100 else \"\"),\n                \"hasAttachments\": len(m.attachments or []) > 0,\n                \"jorbId\": m.jorb_id,\n            }\n            for m in messages\n        ],\n    }\n```\n\nAdd route in `server/routes.py`:\n\n```python\nRoute(\"/actions/sms/messages\", get_sms_messages_handler, methods=[\"GET\"]),\n```\n\nAdd to OpenAPI spec.\n\n### 10. Web Dashboard: Telegram Bot Setup\n\nAdd a new card to frank-bot-web for configuring the Telegram bot:\n\n**Features:**\n- Input field for bot token (with link to BotFather instructions)\n- \"Test Connection\" button that sends a test message\n- Display of current chat ID once configured\n- Status indicator (connected/not configured)\n\n**API endpoints needed:**\n- `GET /telegram-bot/status` - Check if bot is configured\n- `POST /telegram-bot/test` - Send test notification\n- `POST /telegram-bot/configure` - Save token/chat_id (protected by Stytch)\n\n## Files to Create/Modify\n\n### Create:\n- `schemas/sms.schema.json` - Message schema\n- `services/sms_storage.py` - File-based message storage\n- `services/contact_lookup.py` - Phone â†’ Contact reverse lookup\n- `services/telegram_bot.py` - Bot API client for notifications\n- `server/sms_webhook.py` - Webhook handler\n\n### Modify:\n- `server/routes.py` - Add webhook route, SMS messages route\n- `server/app.py` - Wire up webhook\n- `actions/sms.py` - Add get_sms_messages_action\n- `services/telnyx_sms.py` - Store outbound messages\n- `services/vault_client.py` - Add get_telegram_bot_credentials()\n- `config.py` - Add telegram_bot_token, telegram_bot_chat_id\n- `terraform/vault/variables.tf` - Add telegram bot vars\n- `terraform/vault/secrets.tf` - Add telegram-bot secret\n- `openapi/spec.json` - Add /actions/sms/messages endpoint\n- `web/src/components/` - Add telegram-bot-card.ts\n\n## Success Criteria\n\n1. âœ… Webhook receives inbound SMS from Telnyx\n2. âœ… MMS attachments are downloaded and stored alongside message JSON\n3. âœ… Contact name is resolved via Google Contacts reverse lookup\n4. âœ… Messages stored as JSON files in `./data/sms/+{number}/` directory\n5. âœ… STOP/HELP compliance handled for unknown contacts only\n6. âœ… Known contacts bypass compliance formalities\n7. âœ… Outbound SMS also stored for complete conversation history\n8. âœ… Unknown non-spam senders trigger Telegram bot notification\n9. âœ… `GET /actions/sms/messages` returns recent messages\n10. âœ… Web UI allows configuring Telegram bot for notifications\n\n## Companion Prompt for let-food-into-civic\n\nSee `let-food-into-civic-disable-sms-webhook.md` for the prompt to disable the SMS webhook in that repo. The voice webhook (`/webhook/voice`) remains unchanged.\n\n## Pre-completed Setup\n\nThe following has already been configured:\n\n### Telnyx Webhook (DONE)\n- Inbound webhook URL changed to `https://frank-bot-api.contrived.com/webhook/sms`\n- Outbound webhook: not configured (delivery receipts not needed for now)\n\n### Telegram Bot (DONE)\n- **Bot name**: Frank Bot\n- **Username**: @Seans_frank_bot\n- **Vault path**: `secret/frank-bot/telegram-bot` (contains `token` and `chat_id`)\n- **Sean's chat ID**: 182710670\n\n### Vault Terraform (DONE)\n- `terraform/vault/variables.tf` - Added `telegram_bot_token` and `telegram_bot_chat_id`\n- `terraform/vault/secrets.tf` - Added `vault_kv_secret_v2.telegram_bot`\n- Secret already stored in Vault\n\n### Schema (DONE)\n- `schemas/sms.schema.json` - Already created\n\n## Remaining Implementation\n\nAll infrastructure is ready. Implementation needs:\n1. Create `/webhook/sms` endpoint (currently will 404)\n2. Create services (sms_storage.py, contact_lookup.py, telegram_bot.py)\n3. Add ChatGPT action for reading messages\n4. Update outbound SMS to also store messages\n5. Web UI for telegram bot status (optional)",
  "executions": []
}
