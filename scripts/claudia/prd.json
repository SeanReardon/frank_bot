{
  "project": "frank_bot",
  "version": "0.1.0",
  "branchName": "main",
  "userStories": [
    {
      "id": "frank_bot-00001",
      "title": "Create meta module structure and FrankAPI namespace classes",
      "acceptanceCriteria": [
        "Create meta/ directory with __init__.py, api.py, executor.py, introspection.py files",
        "FrankAPI class exists with namespace properties: calendar, contacts, sms, swarm, ups, time",
        "Each namespace class (CalendarNamespace, ContactsNamespace, etc.) is defined with stub methods",
        "FrankAPI() can be instantiated without errors",
        "Namespace methods are synchronous wrappers that will call existing async actions"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Foundation task - all other meta module tasks depend on this. Focus on structure, not implementation."
    },
    {
      "id": "frank_bot-00002",
      "title": "Implement CalendarNamespace with sync wrappers for existing calendar actions",
      "acceptanceCriteria": [
        "CalendarNamespace.events() calls the existing calendar events action synchronously via asyncio.run()",
        "CalendarNamespace.create() wraps the create event action",
        "CalendarNamespace.list() wraps the list calendars action",
        "Methods accept the same parameters as the underlying actions",
        "Methods return the same dict structure as the underlying actions",
        "Unit tests verify the namespace methods work correctly"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Depends on frank_bot-00001. Template for other namespace implementations."
    },
    {
      "id": "frank_bot-00003",
      "title": "Implement remaining namespace classes (contacts, sms, swarm, ups, time)",
      "acceptanceCriteria": [
        "ContactsNamespace.search(query) wraps contact search action",
        "SMSNamespace.send(recipient, message) wraps SMS send action",
        "SwarmNamespace.checkins() wraps search_checkins_action with all parameters (year, category, with_companion, max_results)",
        "UPSNamespace.status() wraps UPS status action",
        "TimeNamespace.now(timezone=None) wraps time/NTP action",
        "All methods are synchronous using asyncio.run()",
        "Unit tests for each namespace"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Depends on frank_bot-00001 and follows pattern from frank_bot-00002."
    },
    {
      "id": "frank_bot-00004",
      "title": "Implement script storage and parsing utilities",
      "acceptanceCriteria": [
        "Scripts are stored as .py files in ./data/scripts/ directory",
        "Script filenames follow pattern: {ISO8601-timestamp}-{slug}.py",
        "Docstring parser extracts: description (first paragraph), parameters (from Parameters: section), example (from Example: section)",
        "Function to list all scripts with metadata (id, description, parameters, example, created_at)",
        "Function to get a specific script's code by ID",
        "Function to save a new script with slug and code",
        "Unit tests for docstring parsing"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Depends on frank_bot-00001 for module structure. Blocking for frank_bot-00006 and frank_bot-00007."
    },
    {
      "id": "frank_bot-00005",
      "title": "Implement job storage and management",
      "acceptanceCriteria": [
        "Jobs are stored as .json files in ./data/jobs/ directory",
        "Job filenames follow pattern: {ISO8601-timestamp}-{slug}-run.json",
        "Job JSON contains: job_id, script_id, status, params, started_at, completed_at, stdout, stderr, result, error",
        "Status values: pending, running, completed, failed, timeout",
        "Function to create a new job record",
        "Function to update job status and results",
        "Function to list all jobs with status",
        "Function to get a specific job by ID",
        "Unit tests for job CRUD operations"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Depends on frank_bot-00001. Blocking for frank_bot-00008."
    },
    {
      "id": "frank_bot-00006",
      "title": "Implement script executor with timeout and output capture",
      "acceptanceCriteria": [
        "executor.py has function to execute a script's main() function",
        "FrankAPI instance is passed as first argument to main()",
        "Script params are passed as keyword arguments",
        "stdout and stderr are captured during execution",
        "Return value from main() is captured as result",
        "10-minute timeout implemented - script is terminated if exceeded",
        "Timeout results in status='timeout' with clear error message",
        "Exceptions during execution are caught and stored in error field",
        "Execution runs in a background thread to not block",
        "Unit tests with mock scripts verifying output capture, timeout, and error handling"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Depends on frank_bot-00001, frank_bot-00002, frank_bot-00003 (needs working FrankAPI), frank_bot-00004, frank_bot-00005."
    },
    {
      "id": "frank_bot-00007",
      "title": "Implement introspection module for meta documentation generation",
      "acceptanceCriteria": [
        "introspection.py generates Markdown documentation from FrankAPI",
        "Documentation includes: quick start example, all services with method tables",
        "Method tables show: method name, signature with parameters, description",
        "Documentation includes execution instructions (POST /frank/execute workflow)",
        "Generated documentation matches the format specified in the PRD",
        "Unit test verifies documentation structure"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Depends on frank_bot-00001, frank_bot-00002, frank_bot-00003 (needs complete FrankAPI to document)."
    },
    {
      "id": "frank_bot-00008",
      "title": "Add GET /frank/meta and GET /frank/scripts endpoints",
      "acceptanceCriteria": [
        "GET /frank/meta returns Markdown documentation from introspection module",
        "GET /frank/scripts returns JSON list of all saved scripts with metadata",
        "GET /frank/scripts/{id} returns a specific script's code",
        "Endpoints follow existing route patterns in server/routes.py",
        "Endpoints are protected by existing API key auth",
        "Integration tests for each endpoint"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Depends on frank_bot-00004, frank_bot-00007."
    },
    {
      "id": "frank_bot-00009",
      "title": "Add POST /frank/execute endpoint",
      "acceptanceCriteria": [
        "POST /frank/execute accepts JSON with: slug, code, params (for new script)",
        "POST /frank/execute accepts JSON with: script_id, params (for existing script)",
        "Endpoint saves new script if code provided",
        "Endpoint creates job record and starts execution in background",
        "Returns immediately with job_id and status='running'",
        "Multiple concurrent executions are supported",
        "Endpoint protected by existing API key auth",
        "Integration tests for both new script and existing script execution"
      ],
      "priority": 9,
      "passes": true,
      "notes": "Depends on frank_bot-00004, frank_bot-00005, frank_bot-00006."
    },
    {
      "id": "frank_bot-00010",
      "title": "Add GET /frank/jobs endpoints",
      "acceptanceCriteria": [
        "GET /frank/jobs returns JSON list of all job runs with status",
        "GET /frank/jobs/{id} returns full job details: job_id, script_id, status, params, started_at, completed_at, stdout, stderr, result, error",
        "Completed jobs include the result from main()",
        "Failed/timeout jobs include error message",
        "Endpoints protected by existing API key auth",
        "Integration tests for job listing and retrieval"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Depends on frank_bot-00005, frank_bot-00009 (needs jobs to exist)."
    },
    {
      "id": "frank_bot-00011",
      "title": "Update OpenAPI spec with new meta endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes /frank/meta endpoint with response schema",
        "openapi/spec.json includes /frank/scripts and /frank/scripts/{id} endpoints",
        "openapi/spec.json includes /frank/execute endpoint with request/response schemas",
        "openapi/spec.json includes /frank/jobs and /frank/jobs/{id} endpoints",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json",
        "Request/response schemas accurately reflect the API"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Depends on frank_bot-00008, frank_bot-00009, frank_bot-00010. Can be done in parallel with integration testing."
    },
    {
      "id": "frank_bot-00012",
      "title": "Update instructions_for_chatgpt.txt with script execution guidance",
      "acceptanceCriteria": [
        "Instructions explain when to use execute (pagination, filtering, aggregation, combining data sources)",
        "Instructions describe the workflow: meta -> scripts -> execute -> jobs -> present",
        "Instructions emphasize execute is for getting data, not presenting it",
        "Instructions mention checking /frank/scripts for reusable scripts",
        "Instructions include example use case (hotels in SF)",
        "Instructions reference /frank/meta for understanding capabilities"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Can be done after API implementation is complete. No hard dependencies but should reflect final API."
    },
    {
      "id": "frank_bot-00013",
      "title": "Ensure data volume is mounted in Docker configuration",
      "acceptanceCriteria": [
        "docker-compose.yml mounts ./data:/app/data volume",
        "Container can write to ./data/scripts/ and ./data/jobs/ directories",
        "Data persists across container restarts",
        "README documents the data directory structure"
      ],
      "priority": 13,
      "passes": true,
      "notes": "Infrastructure task. Can be done early but testing requires the endpoints to exist."
    },
    {
      "id": "frank_bot-00014",
      "title": "Add Telethon dependency and Telegram configuration settings",
      "acceptanceCriteria": [
        "telethon package added to pyproject.toml dependencies",
        "poetry.lock updated with telethon and its dependencies",
        "config.py updated with new settings: TELEGRAM_API_ID, TELEGRAM_API_HASH, TELEGRAM_PHONE, TELEGRAM_SESSION_NAME",
        "TELEGRAM_SESSION_NAME defaults to 'frank_bot' if not set",
        ".env.example updated with Telegram environment variable placeholders",
        ".gitignore updated to ignore *.session files (Telethon session files)"
      ],
      "priority": 14,
      "passes": true,
      "notes": "Foundation task for Telegram integration - all other Telegram tasks depend on this."
    },
    {
      "id": "frank_bot-00015",
      "title": "Create TelegramClientService with Telethon wrapper",
      "acceptanceCriteria": [
        "services/telegram_client.py file created following existing service patterns",
        "TelegramClientService class initialized with API credentials from config",
        "is_configured property returns True only when API_ID, API_HASH, and PHONE are set",
        "Session file stored in configurable location (default: project root)",
        "Async connect() method initializes and starts the Telethon client",
        "Async disconnect() method cleanly shuts down the client",
        "Service handles missing credentials gracefully with clear error messages"
      ],
      "priority": 15,
      "passes": true,
      "notes": "Depends on frank_bot-00014. Core service wrapper - blocking for frank_bot-00016."
    },
    {
      "id": "frank_bot-00016",
      "title": "Implement TelegramClientService message sending and retrieval methods",
      "acceptanceCriteria": [
        "send_message(recipient, text) method sends message to user/bot by username or phone",
        "get_messages(chat_id, limit) method retrieves recent messages from a chat",
        "get_dialogs(limit) method lists recent conversations with metadata",
        "mark_read(chat_id) method marks messages as read in a chat",
        "All methods are async and properly await Telethon operations",
        "Methods return structured result objects (dataclasses) similar to SMSResult pattern",
        "Error handling for: recipient not found, rate limiting, session invalidation",
        "Unit tests with mocked Telethon client verify method behavior"
      ],
      "priority": 16,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Implements the core Telegram functionality."
    },
    {
      "id": "frank_bot-00017",
      "title": "Create Telegram action handlers",
      "acceptanceCriteria": [
        "actions/telegram.py file created following existing action patterns",
        "send_telegram_message(arguments) action sends message with recipient and text parameters",
        "get_telegram_messages(arguments) action retrieves messages with chat and limit parameters",
        "list_telegram_chats(arguments) action lists recent conversations with limit parameter",
        "Actions follow signature: async def action_name(arguments: dict[str, Any] | None = None) -> dict[str, Any]",
        "Actions return structured dicts with success status and relevant data",
        "Actions raise ValueError with clear messages on validation failures",
        "Unit tests verify action behavior with mocked TelegramClientService"
      ],
      "priority": 17,
      "passes": true,
      "notes": "Depends on frank_bot-00016. Action layer between routes and service."
    },
    {
      "id": "frank_bot-00018",
      "title": "Add Telegram routes to server",
      "acceptanceCriteria": [
        "GET /telegram/send route added to server/routes.py",
        "GET /telegram/messages route added to server/routes.py",
        "GET /telegram/chats route added to server/routes.py",
        "Routes use _build_responder wrapper pattern like existing routes",
        "Routes accept query parameters matching action arguments",
        "Routes protected by existing API key authentication",
        "Integration tests verify routes call correct actions"
      ],
      "priority": 18,
      "passes": true,
      "notes": "Depends on frank_bot-00017. Exposes Telegram functionality via HTTP."
    },
    {
      "id": "frank_bot-00019",
      "title": "Update OpenAPI spec with Telegram endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes GET /telegram/send endpoint with query parameters and response schema",
        "openapi/spec.json includes GET /telegram/messages endpoint with query parameters and response schema",
        "openapi/spec.json includes GET /telegram/chats endpoint with query parameters and response schema",
        "Schemas accurately describe request parameters and response structures",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json",
        "Endpoint descriptions explain the user account context (not a bot)"
      ],
      "priority": 19,
      "passes": true,
      "notes": "Depends on frank_bot-00018. Documents API for ChatGPT/OpenAI integration."
    },
    {
      "id": "frank_bot-00020",
      "title": "Create Telegram session setup script",
      "acceptanceCriteria": [
        "scripts/setup_telegram_session.py created for interactive first-time auth",
        "Script prompts for phone number if not in environment",
        "Script handles Telegram verification code input (SMS or app)",
        "Script creates .session file upon successful authentication",
        "Script provides clear instructions and error messages",
        "Script can be run standalone: poetry run python scripts/setup_telegram_session.py",
        "README updated with Telegram setup instructions referencing this script"
      ],
      "priority": 20,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Required for first-time Telegram authentication in server/Docker context."
    },
    {
      "id": "frank_bot-00021",
      "title": "Add TelegramNamespace to FrankAPI for script execution",
      "acceptanceCriteria": [
        "TelegramNamespace class added to meta/api.py",
        "TelegramNamespace.send(recipient, text) wraps send_telegram_message action",
        "TelegramNamespace.messages(chat, limit) wraps get_telegram_messages action",
        "TelegramNamespace.chats(limit) wraps list_telegram_chats action",
        "FrankAPI.telegram property returns TelegramNamespace instance",
        "Methods are synchronous wrappers using asyncio.run() pattern",
        "Unit tests verify namespace methods work correctly",
        "Introspection module updated to include TelegramNamespace in documentation"
      ],
      "priority": 21,
      "passes": true,
      "notes": "Depends on frank_bot-00017. Enables Telegram access in meta script execution."
    },
    {
      "id": "frank_bot-00022",
      "title": "Update TelegramClientService to use DATA_DIR for session file location",
      "acceptanceCriteria": [
        "services/telegram_client.py updated to read DATA_DIR environment variable",
        "Session file path constructed as: os.path.join(os.getenv('DATA_DIR', '.'), settings.telegram_session_name)",
        "Session file is created in /app/data/ when DATA_DIR=/app/data",
        "Existing session files in project root still work when DATA_DIR is not set",
        "Unit test verifies session path construction logic"
      ],
      "priority": 22,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Required for sharing session between API and web containers via mounted volume."
    },
    {
      "id": "frank_bot-00023",
      "title": "Add GET /telegram/status endpoint",
      "acceptanceCriteria": [
        "GET /telegram/status route added to server/routes.py",
        "Returns JSON: { status: 'not_configured' | 'needs_auth' | 'connected', account?: { name, username, phone } }",
        "Status 'not_configured' when TELEGRAM_API_ID, TELEGRAM_API_HASH, or TELEGRAM_PHONE env vars missing",
        "Status 'needs_auth' when env vars present but session file missing or unauthorized",
        "Status 'connected' when session is authorized, includes account info from get_me()",
        "Endpoint does NOT require Stytch auth (public status check)",
        "Integration test verifies all three status states"
      ],
      "priority": 23,
      "passes": true,
      "notes": "Depends on frank_bot-00015, frank_bot-00022. Foundation endpoint for web dashboard Telegram card."
    },
    {
      "id": "frank_bot-00024",
      "title": "Add Stytch session validation middleware for protected routes",
      "acceptanceCriteria": [
        "New middleware function validates stytch_session_token cookie",
        "Middleware calls Stytch API to verify session is valid",
        "STYTCH_PROJECT_ID and STYTCH_SECRET environment variables added to config",
        "Invalid/missing session returns 401 Unauthorized JSON response",
        "Middleware can be applied to specific routes via decorator or route configuration",
        "Unit tests with mocked Stytch API verify validation logic"
      ],
      "priority": 24,
      "passes": true,
      "notes": "No direct dependencies. Required for protecting Telegram auth endpoints. Reference ~/dev/contrived-site/ for Stytch integration patterns."
    },
    {
      "id": "frank_bot-00025",
      "title": "Add POST /telegram/auth/start endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/start route added to server/routes.py",
        "Accepts JSON body: { phone?: string } (optional, uses TELEGRAM_PHONE env var if not provided)",
        "Returns JSON: { status: 'code_sent' | 'already_authorized' | 'error', phoneCodeHash?: string }",
        "Calls Telethon send_code_request() to trigger verification code",
        "Returns phoneCodeHash needed for verification step",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies code sending flow (mocked Telegram API)"
      ],
      "priority": 25,
      "passes": true,
      "notes": "Depends on frank_bot-00015, frank_bot-00024. First step in web-based Telegram auth flow."
    },
    {
      "id": "frank_bot-00026",
      "title": "Add POST /telegram/auth/verify endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/verify route added to server/routes.py",
        "Accepts JSON body: { code: string, phoneCodeHash: string }",
        "Returns JSON: { status: 'success' | 'invalid_code' | 'needs_2fa' | 'error' }",
        "Calls Telethon sign_in() with verification code",
        "Returns 'needs_2fa' if account has two-factor authentication enabled",
        "On success, session file is created/updated",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies verification flow including 2FA detection"
      ],
      "priority": 26,
      "passes": true,
      "notes": "Depends on frank_bot-00025. Second step in web-based Telegram auth flow."
    },
    {
      "id": "frank_bot-00027",
      "title": "Add POST /telegram/auth/2fa endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/2fa route added to server/routes.py",
        "Accepts JSON body: { password: string }",
        "Returns JSON: { status: 'success' | 'invalid_password' | 'error' }",
        "Calls Telethon sign_in() with 2FA password",
        "On success, session file is created/updated",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies 2FA completion flow"
      ],
      "priority": 27,
      "passes": true,
      "notes": "Depends on frank_bot-00026. Final step in web-based Telegram auth flow for 2FA accounts."
    },
    {
      "id": "frank_bot-00028",
      "title": "Add GET /telegram/test endpoint",
      "acceptanceCriteria": [
        "GET /telegram/test route added to server/routes.py",
        "Returns JSON: { connected: boolean, dialogs?: [first 3 chats], error?: string }",
        "When connected, fetches first 3 dialogs via get_dialogs(limit=3)",
        "When not connected, returns connected: false with error message",
        "Endpoint does NOT require Stytch auth (allows testing from ChatGPT)",
        "Integration test verifies connected and disconnected states"
      ],
      "priority": 28,
      "passes": true,
      "notes": "Depends on frank_bot-00016, frank_bot-00023. Provides connection test functionality for dashboard."
    },
    {
      "id": "frank_bot-00029",
      "title": "Create web/ directory with Vite + TypeScript + Lit project scaffold",
      "acceptanceCriteria": [
        "web/ directory created with package.json including: lit 3.x, vite 5.x, typescript",
        "vite.config.ts configured with dual build mode (dev SPA + library IIFE bundle)",
        "tsconfig.json with strict mode, decorators enabled, ES2020 target",
        "web/src/ directory structure: components/, lib/, styles/",
        "web/index.html for dev preview page",
        "npm run dev starts Vite dev server with API proxy to http://frank-bot:8000",
        "npm run build creates dist/ for dev and dist-lib/bundle.js for embedding"
      ],
      "priority": 29,
      "passes": true,
      "notes": "No dependencies. Foundation for all frontend tasks. Follow ~/dev/claudia/web/ patterns."
    },
    {
      "id": "frank_bot-00030",
      "title": "Create web/Dockerfile with multi-stage build",
      "acceptanceCriteria": [
        "web/Dockerfile created with two stages: node:20-alpine builder, nginx:alpine production",
        "Builder stage runs npm ci and npm run build:lib",
        "Production stage copies dist-lib/bundle.js and nginx.conf",
        "Health check configured for container",
        "Image builds successfully: docker build -t frank_bot-web ./web",
        "Container serves bundle.js at /bundle.js"
      ],
      "priority": 30,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required for containerized deployment."
    },
    {
      "id": "frank_bot-00031",
      "title": "Create web/nginx.conf with API proxy and static file serving",
      "acceptanceCriteria": [
        "web/nginx.conf created with routing rules",
        "/api/* requests proxied to http://frank-bot:8000/* (strip /api prefix)",
        "/health returns 200 for container health checks",
        "/* serves static files with SPA fallback (try_files $uri $uri/ /index.html)",
        "/bundle.js served with CORS headers for contrived.com embedding",
        "Gzip compression enabled for text, JSON, JS",
        "Static assets (JS/CSS/images) served with long cache headers"
      ],
      "priority": 31,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required for frank_bot-00030 Dockerfile."
    },
    {
      "id": "frank_bot-00032",
      "title": "Create API client module (web/src/lib/api.ts)",
      "acceptanceCriteria": [
        "web/src/lib/api.ts created following ~/dev/claudia/web/src/api.ts pattern",
        "configure({ apiBase, sessionToken }) function for initialization",
        "request<T>(path, options) wrapper with auth header and error handling",
        "AuthError class for 401/403 responses",
        "getTelegramStatus() function calls GET /telegram/status",
        "startTelegramAuth(phone?) function calls POST /telegram/auth/start",
        "verifyTelegramCode(code, phoneCodeHash) function calls POST /telegram/auth/verify",
        "submitTelegram2FA(password) function calls POST /telegram/auth/2fa",
        "testTelegramConnection() function calls GET /telegram/test",
        "getScripts() function calls GET /frank/scripts",
        "getJobs() function calls GET /frank/jobs"
      ],
      "priority": 32,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required before any frontend components can be built."
    },
    {
      "id": "frank_bot-00033",
      "title": "Create CSS tokens file (web/src/styles/tokens.css)",
      "acceptanceCriteria": [
        "web/src/styles/tokens.css created with CSS custom property fallbacks",
        "Fallback values for: --color-bg, --color-text, --color-primary, --color-border, --color-success, --color-error",
        "Fallback values for: --font-family, --font-size-base, --spacing-unit, --border-radius",
        "Values work standalone for dev mode and inherit from contrived-site when embedded",
        "Tokens imported in main dashboard component"
      ],
      "priority": 33,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Provides theming foundation for components."
    },
    {
      "id": "frank_bot-00034",
      "title": "Create main dashboard component (frank-bot-dashboard.ts)",
      "acceptanceCriteria": [
        "web/src/frank-bot-dashboard.ts created as Lit web component",
        "@customElement('frank-bot-dashboard') decorator applied",
        "Accepts attributes: session-token (optional), api-base (default: /api)",
        "Reads stytch_session_token from cookie if session-token attribute not provided",
        "Initializes API client on connectedCallback()",
        "Renders container with slots for child cards (telegram-card, scripts-card, jobs-card)",
        "Includes activity-tracker-lite.js script for session keepalive",
        "Component renders successfully in dev mode"
      ],
      "priority": 34,
      "passes": true,
      "notes": "Depends on frank_bot-00032, frank_bot-00033. Entry point component for dashboard."
    },
    {
      "id": "frank_bot-00035",
      "title": "Create Telegram card component (telegram-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/telegram-card.ts created as Lit web component",
        "@customElement('telegram-card') decorator applied",
        "Fetches status from /telegram/status on mount",
        "Displays 'not_configured' state with message about missing env vars",
        "Displays 'needs_auth' state with Connect Telegram button",
        "Displays 'connected' state with account info (name, username, phone)",
        "Connected state includes Test Connection button that calls /telegram/test",
        "Uses CSS custom properties from tokens.css for styling"
      ],
      "priority": 35,
      "passes": true,
      "notes": "Depends on frank_bot-00023, frank_bot-00032, frank_bot-00034. Basic status display without auth wizard."
    },
    {
      "id": "frank_bot-00036",
      "title": "Add Telegram auth wizard to telegram-card component",
      "acceptanceCriteria": [
        "telegram-card.ts extended with multi-step auth wizard",
        "Step 1: Click Connect Telegram -> calls /telegram/auth/start -> shows code input",
        "Step 2: Enter verification code -> calls /telegram/auth/verify",
        "Step 3 (conditional): If needs_2fa, show password input -> calls /telegram/auth/2fa",
        "Success state transitions to 'connected' display",
        "Error states show clear messages and allow retry",
        "Loading states shown during API calls",
        "phoneCodeHash maintained in component state between steps"
      ],
      "priority": 36,
      "passes": true,
      "notes": "Depends on frank_bot-00025, frank_bot-00026, frank_bot-00027, frank_bot-00035. Completes Telegram setup wizard."
    },
    {
      "id": "frank_bot-00037",
      "title": "Create scripts card component (scripts-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/scripts-card.ts created as Lit web component",
        "@customElement('scripts-card') decorator applied",
        "Fetches scripts list from GET /frank/scripts on mount",
        "Displays list of scripts with: name, description, execution count, last run time",
        "Empty state shown when no scripts exist",
        "Click on script shows expanded details (full description, example code)",
        "Refresh button to reload scripts list",
        "Uses CSS custom properties from tokens.css for styling"
      ],
      "priority": 37,
      "passes": true,
      "notes": "Depends on frank_bot-00008, frank_bot-00032, frank_bot-00034. Displays meta scripts."
    },
    {
      "id": "frank_bot-00038",
      "title": "Create jobs card component (jobs-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/jobs-card.ts created as Lit web component",
        "@customElement('jobs-card') decorator applied",
        "Fetches jobs list from GET /frank/jobs on mount",
        "Displays list of jobs with: script name, status badge, started_at, duration",
        "Status badges color-coded: pending (gray), running (blue), completed (green), failed (red)",
        "Empty state shown when no jobs exist",
        "Click on job shows expanded details (stdout, stderr, result/error)",
        "Filter dropdown to filter by status (all, pending, running, completed, failed)",
        "Auto-refresh toggle for polling running jobs"
      ],
      "priority": 38,
      "passes": true,
      "notes": "Depends on frank_bot-00010, frank_bot-00032, frank_bot-00034. Displays job executions."
    },
    {
      "id": "frank_bot-00039",
      "title": "Add CI/CD workflow for web container build and push",
      "acceptanceCriteria": [
        ".github/workflows/build_and_push.yml updated to include web container build",
        "Workflow builds ./web/Dockerfile",
        "Image pushed to ghcr.io/seanreardon/frank_bot-web:latest",
        "Build triggered on changes to web/ directory",
        "Build uses same authentication/registry patterns as existing frank_bot image",
        "Workflow passes on PR and main branch"
      ],
      "priority": 39,
      "passes": true,
      "notes": "Depends on frank_bot-00030. Final deployment step for web dashboard. Web container build job added to workflow."
    },
    {
      "id": "frank_bot-00040",
      "title": "Create SMSStorage service for file-based message persistence",
      "acceptanceCriteria": [
        "services/sms_storage.py created with SMSStorage class",
        "SMSMessage Pydantic model created matching schemas/sms.schema.json",
        "store_message(message: SMSMessage) writes JSON to ./data/sms/{localNumber}/ directory",
        "Filename pattern: {ISO8601-timestamp}-{contact-name-or-phone}.json (using - instead of : for filesystem)",
        "Contact name sanitized for filesystem (replace <>/:\"/\\|?* with _)",
        "If no contact, use phone number with + as filename identifier",
        "get_recent_messages(local_number, remote_number, contact_name, limit) retrieves and filters stored messages",
        "Messages sorted by timestamp descending (most recent first)",
        "Unit tests verify storage, retrieval, and filename generation"
      ],
      "priority": 40,
      "passes": true,
      "notes": "Foundation for SMS storage. Blocking for frank_bot-00041, frank_bot-00042, frank_bot-00046."
    },
    {
      "id": "frank_bot-00041",
      "title": "Add MMS attachment download and storage to SMSStorage",
      "acceptanceCriteria": [
        "SMSStorage._download_attachment(url, filepath) downloads media from Telnyx URL",
        "Uses httpx async client with proper timeout handling",
        "Attachment filenames follow pattern: {timestamp}-{contact}-attachment-{n}.{ext}",
        "Extension determined from MIME type using mimetypes.guess_extension()",
        "Falls back to .bin extension if MIME type unknown",
        "store_message() downloads attachments before writing JSON",
        "Attachment.filename field updated with local filename after download",
        "Unit tests with mocked HTTP responses verify download logic"
      ],
      "priority": 41,
      "passes": true,
      "notes": "Depends on frank_bot-00040. Extends SMSStorage to handle MMS attachments."
    },
    {
      "id": "frank_bot-00042",
      "title": "Create ContactLookup service for phone-to-contact reverse lookup",
      "acceptanceCriteria": [
        "services/contact_lookup.py created with ContactLookup class",
        "lookup(phone_number: str) searches Google Contacts for matching phone",
        "Phone numbers normalized for comparison (strip spaces, dashes, handle country codes)",
        "Returns Contact dataclass with name and googleContactId, or None if not found",
        "In-memory cache prevents repeated API calls for same number",
        "Uses existing GoogleContactsService for API access",
        "Unit tests with mocked contacts verify lookup and caching behavior"
      ],
      "priority": 42,
      "passes": true,
      "notes": "Depends on existing GoogleContactsService. Blocking for frank_bot-00044."
    },
    {
      "id": "frank_bot-00043",
      "title": "Create TelegramBot service for notification messages",
      "acceptanceCriteria": [
        "services/telegram_bot.py created with TelegramBot class (separate from Telethon user client)",
        "Uses Telegram Bot API via httpx (not Telethon)",
        "TelegramBot(token, chat_id) constructor with credentials",
        "send_notification(text, parse_mode='HTML') sends message to configured chat",
        "notify_unknown_sms(from_number, message, attachments) formats and sends unknown sender alert",
        "notify_spam(from_number, message, reason) formats and sends spam alert",
        "get_telegram_bot_credentials() added to services/vault_client.py to fetch from Vault",
        "config.py updated with TELEGRAM_BOT_TOKEN and TELEGRAM_BOT_CHAT_ID settings",
        "Unit tests with mocked HTTP verify notification formatting"
      ],
      "priority": 43,
      "passes": true,
      "notes": "No dependencies. Uses Bot API not Telethon. Blocking for frank_bot-00045."
    },
    {
      "id": "frank_bot-00044",
      "title": "Create SMS webhook endpoint for inbound Telnyx messages",
      "acceptanceCriteria": [
        "server/sms_webhook.py created with sms_webhook_handler(request) async function",
        "Route POST /webhook/sms added to server/routes.py (no API key required)",
        "Handler extracts event_type and direction from Telnyx payload",
        "Skips non-inbound messages (outbound confirmations, delivery receipts)",
        "For inbound messages: parses from_number, to_number, text, media array, telnyx_id",
        "Calls ContactLookup to resolve sender to contact",
        "Creates SMSMessage object with all fields populated",
        "Calls SMSStorage.store_message() to persist immediately",
        "Returns JSON {status: 'processed'} or {status: 'skipped', reason: '...'}"
      ],
      "priority": 44,
      "passes": true,
      "notes": "Depends on frank_bot-00040, frank_bot-00042. Core webhook handler without compliance or routing logic."
    },
    {
      "id": "frank_bot-00045",
      "title": "Add STOP/HELP compliance handling for unknown contacts",
      "acceptanceCriteria": [
        "sms_webhook_handler checks for compliance keywords ONLY when contact is None",
        "STOP command: records opt-out (could be simple file or database), sends confirmation SMS",
        "HELP command: sends help message with contact info via Telnyx SMS",
        "START/YES/OPTIN/SUBSCRIBE commands: records opt-in, sends confirmation",
        "Known contacts bypass all compliance handling (proceed to normal processing)",
        "Compliance messages stored with classification='compliance'",
        "opt_outs.json file in ./data/ tracks opted-out phone numbers",
        "Unit tests verify compliance flows for unknown contacts"
      ],
      "priority": 45,
      "passes": true,
      "notes": "Depends on frank_bot-00044. Extends webhook with regulatory compliance for unknown senders."
    },
    {
      "id": "frank_bot-00046",
      "title": "Add Telegram Bot notifications for unknown SMS senders",
      "acceptanceCriteria": [
        "sms_webhook_handler sends Telegram notification after storing unknown sender messages",
        "Notification includes: from_number, message preview (truncated at 500 chars), attachment count",
        "Uses TelegramBot.notify_unknown_sms() method",
        "Notification only sent when contact is None and message is not compliance-related",
        "Gracefully handles Telegram API failures (log error, don't fail webhook)",
        "Classification set to 'unknown' for messages triggering notification",
        "Integration test verifies notification is sent for unknown senders"
      ],
      "priority": 46,
      "passes": true,
      "notes": "Depends on frank_bot-00043, frank_bot-00044. Adds notification flow for unknown contacts."
    },
    {
      "id": "frank_bot-00047",
      "title": "Update outbound SMS to also store messages",
      "acceptanceCriteria": [
        "services/telnyx_sms.py send_sms() modified to store outbound messages",
        "After successful send, creates SMSMessage with direction='outbound'",
        "Calls ContactLookup to resolve recipient to contact (for consistent naming)",
        "Sets processed=True for outbound messages (already 'processed')",
        "Stores via SMSStorage.store_message()",
        "Existing send_sms behavior unchanged (still returns SMSResult)",
        "Unit tests verify outbound messages are stored alongside inbound"
      ],
      "priority": 47,
      "passes": true,
      "notes": "Depends on frank_bot-00040, frank_bot-00042. Creates complete conversation history."
    },
    {
      "id": "frank_bot-00048",
      "title": "Add ChatGPT action and route for reading SMS messages",
      "acceptanceCriteria": [
        "actions/sms.py created with get_sms_messages_action(arguments) function",
        "Accepts parameters: limit (default 50, max 100), contact (fuzzy match), phone, direction",
        "Returns JSON with count and messages array",
        "Each message includes: timestamp, direction, contact name (if known), phone, preview (100 chars), hasAttachments, jorbId",
        "GET /actions/sms/messages route added to server/routes.py",
        "Route protected by existing API key authentication",
        "OpenAPI spec updated with /actions/sms/messages endpoint definition",
        "Integration tests verify filtering by contact, phone, and direction"
      ],
      "priority": 48,
      "passes": true,
      "notes": "Depends on frank_bot-00040. Exposes SMS history to ChatGPT."
    },
    {
      "id": "frank_bot-00049",
      "title": "Create web dashboard Telegram Bot status card",
      "acceptanceCriteria": [
        "GET /telegram-bot/status endpoint added returning {configured: boolean, chatId?: string}",
        "Checks if TELEGRAM_BOT_TOKEN and TELEGRAM_BOT_CHAT_ID are set",
        "POST /telegram-bot/test endpoint sends test notification via TelegramBot",
        "Returns {success: boolean, error?: string}",
        "web/src/components/telegram-bot-card.ts created as Lit component",
        "Card displays configuration status (configured/not configured)",
        "Test Connection button calls POST /telegram-bot/test and shows result",
        "Uses existing dashboard CSS tokens for styling"
      ],
      "priority": 49,
      "passes": true,
      "notes": "Depends on frank_bot-00043, frank_bot-00034. Optional web UI for Telegram bot status."
    },
    {
      "id": "frank_bot-00050",
      "title": "Add SMS messages card to web dashboard",
      "acceptanceCriteria": [
        "web/src/lib/api.ts extended with getSmsMessages(options) function",
        "web/src/components/sms-card.ts created as Lit component",
        "Card fetches and displays recent SMS messages from GET /actions/sms/messages",
        "Displays messages grouped by conversation (remote number)",
        "Shows contact name if known, phone number otherwise",
        "Inbound/outbound messages visually distinguished (alignment or color)",
        "MMS attachment indicator shown when hasAttachments is true",
        "Refresh button to reload messages",
        "Filter by contact/phone input field"
      ],
      "priority": 50,
      "passes": true,
      "notes": "Depends on frank_bot-00048, frank_bot-00034. Displays SMS history in web UI."
    },
    {
      "id": "frank_bot-00051",
      "title": "Create jorb_storage.py with SQLite persistence for jorbs and messages",
      "acceptanceCriteria": [
        "services/jorb_storage.py created with JorbStorage class",
        "aiosqlite added to pyproject.toml dependencies",
        "SQLite schema created with jorbs, jorb_messages, and jorb_checkpoints tables",
        "Jorb dataclass with fields: id, name, status, original_plan, contacts_json, progress_summary, created_at, updated_at, paused_reason, needs_approval_for, awaiting",
        "JorbMessage dataclass with fields: id, jorb_id, timestamp, direction, channel, sender, sender_name, recipient, content, agent_reasoning",
        "create_jorb(name, plan, contacts) returns new Jorb with generated ID",
        "get_jorb(jorb_id) returns Jorb or None",
        "list_jorbs(status_filter) returns list of Jorb objects (filters: open, closed, all)",
        "update_jorb(jorb_id, **updates) updates jorb fields and returns updated Jorb",
        "Database file stored at JORBS_DB_PATH (default: ./data/jorbs.db)",
        "Unit tests verify CRUD operations"
      ],
      "priority": 51,
      "passes": true,
      "notes": "Foundation for jorbs system. Blocks all other jorb tasks. Status values: planning, running, paused, complete, failed, cancelled."
    },
    {
      "id": "frank_bot-00052",
      "title": "Add message tracking methods to JorbStorage",
      "acceptanceCriteria": [
        "add_message(jorb_id, message: JorbMessage) inserts message and returns message ID",
        "get_messages(jorb_id, limit=50) returns list of JorbMessage objects sorted by timestamp",
        "get_open_jorbs_with_messages() returns list of JorbWithMessages (jorb + all messages) for running/paused jorbs",
        "add_checkpoint(jorb_id, summary, token_count) creates checkpoint record",
        "Messages indexed by jorb_id and timestamp for efficient queries",
        "Unit tests verify message storage and retrieval"
      ],
      "priority": 52,
      "passes": true,
      "notes": "Depends on frank_bot-00051. Extends JorbStorage with message tracking."
    },
    {
      "id": "frank_bot-00053",
      "title": "Create agent_runner.py with OpenAI wrapper and context building",
      "acceptanceCriteria": [
        "services/agent_runner.py created with AgentRunner class",
        "openai package added to pyproject.toml if not present",
        "Uses gpt-5.2 model (hardcoded, not configurable)",
        "OPENAI_API_KEY read from environment",
        "build_context(event, open_jorbs) constructs context dict matching agent_system.md format",
        "call_agent(context) sends to OpenAI API with response_format=json_object",
        "parse_agent_response(response) extracts jorb_id, reasoning, action, task_update from JSON",
        "AgentAction dataclass with type, channel, recipient, content, pause_reason, needs_approval_for",
        "Error handling for API failures with clear error messages",
        "Unit tests with mocked OpenAI client verify context building and response parsing"
      ],
      "priority": 53,
      "passes": true,
      "notes": "Depends on frank_bot-00051, frank_bot-00052. Core LLM integration. Read prompts/agent_system.md for expected format."
    },
    {
      "id": "frank_bot-00054",
      "title": "Implement process_incoming_message in AgentRunner",
      "acceptanceCriteria": [
        "process_incoming_message(event: IncomingEvent) async method processes incoming SMS/Telegram",
        "IncomingEvent dataclass with channel, sender, sender_name, content, timestamp",
        "Fetches all open jorbs with messages from JorbStorage",
        "Enriches event with contact lookup (uses ContactLookup service)",
        "Builds context and calls gpt-5.2 for decision",
        "Stores inbound message in matched jorb's message history",
        "Executes agent action (send_message, pause, complete, no_action)",
        "For send_message: calls appropriate send function (SMS or Telegram)",
        "Stores outbound message with agent_reasoning",
        "Returns AgentResponse with jorb_id, action_taken, success",
        "Unit tests verify message routing and action execution"
      ],
      "priority": 54,
      "passes": true,
      "notes": "Depends on frank_bot-00053, frank_bot-00042 (ContactLookup). Core message processing loop."
    },
    {
      "id": "frank_bot-00055",
      "title": "Implement jorb kickoff flow in AgentRunner",
      "acceptanceCriteria": [
        "kickoff_jorb(jorb: Jorb) async method sends initial message for new jorb",
        "Builds context with jorb_created event type and empty messages array",
        "Calls gpt-5.2 to determine first action",
        "Executes initial send_message action if returned",
        "Stores outbound message in jorb's message history",
        "Updates jorb status from planning to running",
        "Handles case where agent decides no initial action needed",
        "Unit tests verify kickoff flow with mock OpenAI"
      ],
      "priority": 55,
      "passes": true,
      "notes": "Depends on frank_bot-00054. Used when creating jorbs with start_immediately=True."
    },
    {
      "id": "frank_bot-00056",
      "title": "Create actions/jorbs.py with jorb CRUD actions",
      "acceptanceCriteria": [
        "actions/jorbs.py created following existing action patterns",
        "create_jorb_action(arguments) creates jorb with name, plan, contacts, start_immediately (default True)",
        "Contacts validated as array of {identifier, channel, name} objects",
        "If start_immediately=True, calls AgentRunner.kickoff_jorb()",
        "list_jorbs_action(arguments) lists jorbs with status filter (open, closed, all)",
        "get_jorb_action(arguments) returns full jorb details with optional messages",
        "get_jorb_messages_action(arguments) returns message history with limit and offset",
        "Actions follow signature: async def action_name(arguments: dict[str, Any] | None = None)",
        "Unit tests verify action behavior"
      ],
      "priority": 56,
      "passes": true,
      "notes": "Depends on frank_bot-00051, frank_bot-00055. Action layer for jorb management."
    },
    {
      "id": "frank_bot-00057",
      "title": "Add approve and cancel actions for jorbs",
      "acceptanceCriteria": [
        "approve_jorb_action(arguments) approves paused jorb with jorb_id and decision",
        "Updates jorb status from paused to running",
        "Clears paused_reason and needs_approval_for fields",
        "Records approval decision in jorb progress_summary",
        "Triggers agent to process the approval and take next action",
        "cancel_jorb_action(arguments) cancels jorb with jorb_id and optional reason",
        "Updates jorb status to cancelled",
        "Cannot cancel already complete/cancelled jorbs",
        "Unit tests verify approval and cancellation flows"
      ],
      "priority": 57,
      "passes": true,
      "notes": "Depends on frank_bot-00056. Completes jorb lifecycle management."
    },
    {
      "id": "frank_bot-00058",
      "title": "Implement brief_me action for jorb status briefing",
      "acceptanceCriteria": [
        "brief_me_action(arguments) returns activity summary since last briefing",
        "Returns JSON with needs_attention (count), activity_summary, highlights, pending_decisions",
        "needs_attention counts paused jorbs requiring approval",
        "activity_summary lists recent activity per jorb (last N hours configurable)",
        "highlights includes notable events (completions, new contacts, spending)",
        "pending_decisions lists each paused jorb with reason and options",
        "Updates last_briefing_timestamp in persistent state",
        "Unit tests verify briefing content generation"
      ],
      "priority": 58,
      "passes": true,
      "notes": "Depends on frank_bot-00056. Designed for ChatGPT to quickly catch up on jorb status."
    },
    {
      "id": "frank_bot-00059",
      "title": "Add jorb routes to server",
      "acceptanceCriteria": [
        "GET /jorbs route lists jorbs (query param: status)",
        "GET /jorbs/create route creates new jorb (query params: name, plan, contacts JSON, start_immediately)",
        "GET /jorbs/{id} route returns jorb details (query params: include_messages, message_limit)",
        "GET /jorbs/{id}/messages route returns message history (query params: limit, offset)",
        "GET /jorbs/{id}/approve route approves paused jorb (query params: decision)",
        "GET /jorbs/{id}/cancel route cancels jorb (query params: reason)",
        "GET /jorbs/brief route returns briefing",
        "Routes use _build_responder wrapper pattern",
        "Routes protected by existing API key authentication",
        "Integration tests verify routes call correct actions"
      ],
      "priority": 59,
      "passes": true,
      "notes": "Depends on frank_bot-00056, frank_bot-00057, frank_bot-00058. Exposes jorb functionality via HTTP."
    },
    {
      "id": "frank_bot-00060",
      "title": "Update OpenAPI spec with jorb endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes all jorb endpoints with query parameters and response schemas",
        "Jorb schema defined with all fields (id, name, status, plan, contacts, etc.)",
        "JorbMessage schema defined (timestamp, direction, channel, sender, content)",
        "Response schemas for list, create, get, approve, cancel, brief endpoints",
        "Endpoint descriptions explain jorb lifecycle and status meanings",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json"
      ],
      "priority": 60,
      "passes": true,
      "notes": "Depends on frank_bot-00059. Documents API for ChatGPT integration."
    },
    {
      "id": "frank_bot-00061",
      "title": "Implement message debouncing for incoming messages",
      "acceptanceCriteria": [
        "services/message_buffer.py created with MessageBuffer class",
        "Configurable debounce times per channel (DEBOUNCE_TELEGRAM_SECONDS=60, DEBOUNCE_SMS_SECONDS=30)",
        "buffer_message(event) adds message to buffer, returns True if first in window",
        "flush_buffer(sender, channel) returns combined messages and clears buffer",
        "Messages from same sender/channel within window combined with newlines",
        "Timer triggers flush after debounce window expires",
        "message_count field added to flushed event",
        "Unit tests verify debouncing behavior with different timing scenarios"
      ],
      "priority": 61,
      "passes": true,
      "notes": "No direct dependencies but used by frank_bot-00062. Prevents rapid-fire LLM calls."
    },
    {
      "id": "frank_bot-00062",
      "title": "Connect SMS webhook to jorb message processing",
      "acceptanceCriteria": [
        "sms_webhook_handler (from frank_bot-00044) extended to route to jorbs",
        "After storing inbound SMS, calls MessageBuffer.buffer_message()",
        "When debounce timer fires, calls AgentRunner.process_incoming_message()",
        "Messages from known contacts (in any jorb's contacts) processed immediately",
        "Messages from unknown contacts follow existing notification flow",
        "jorbId field populated in SMSMessage when matched to a jorb",
        "Integration test verifies SMS -> debounce -> agent flow"
      ],
      "priority": 62,
      "passes": true,
      "notes": "Depends on frank_bot-00044, frank_bot-00054, frank_bot-00061. Connects SMS to jorb processing."
    },
    {
      "id": "frank_bot-00063",
      "title": "Connect Telegram messages to jorb message processing",
      "acceptanceCriteria": [
        "TelegramClientService extended with on_message callback registration",
        "Callback receives Telethon message events in real-time",
        "Messages routed through MessageBuffer for debouncing",
        "When debounce timer fires, calls AgentRunner.process_incoming_message()",
        "Channel set to 'telegram', sender is username or phone",
        "Contact lookup uses Telegram username/name (not phone-based)",
        "Integration test verifies Telegram -> debounce -> agent flow"
      ],
      "priority": 63,
      "passes": true,
      "notes": "Depends on frank_bot-00016, frank_bot-00054, frank_bot-00061. Connects Telegram to jorb processing."
    },
    {
      "id": "frank_bot-00064",
      "title": "Implement JorbPolicy enforcement in AgentRunner",
      "acceptanceCriteria": [
        "JorbPolicy dataclass with max_spend_without_approval, max_messages_per_hour, require_approval_for, stale_jorb_hours, max_jorb_duration_days",
        "Policy values read from environment (AGENT_SPEND_LIMIT default $100)",
        "Policy included in context sent to gpt-5.2",
        "Rate limiting enforced: track messages per hour per jorb",
        "Auto-pause stale jorbs after stale_jorb_hours of inactivity",
        "Auto-fail jorbs exceeding max_jorb_duration_days",
        "Policy violations logged and reported in brief_me output",
        "Unit tests verify policy enforcement scenarios"
      ],
      "priority": 64,
      "passes": true,
      "notes": "Depends on frank_bot-00054. Adds guardrails to autonomous operation."
    },
    {
      "id": "frank_bot-00065",
      "title": "Implement context reset (Ralph Loop) mechanism",
      "acceptanceCriteria": [
        "CONTEXT_RESET_DAYS environment variable (default 3)",
        "data/jorbs_progress.txt created for progress log",
        "maybe_reset_context() checks if reset needed (days elapsed AND activity occurred)",
        "perform_context_reset() asks gpt-5.2 for structured handoff summary",
        "Handoff includes per-jorb status and session summary",
        "Progress log appended in Claudia-inspired markdown format",
        "Jorb progress_summary fields updated with handoff content",
        "build_fresh_context() includes original plans, current states, last 100 lines of progress log",
        "Unit tests verify reset timing and handoff generation"
      ],
      "priority": 65,
      "passes": true,
      "notes": "Depends on frank_bot-00054. Prevents context overflow in long-running jorbs."
    },
    {
      "id": "frank_bot-00066",
      "title": "Create email_service.py for notifications and digest",
      "acceptanceCriteria": [
        "services/email_service.py created with EmailService class",
        "aiosmtplib added to pyproject.toml dependencies",
        "SMTP settings from environment: SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD",
        "send(to, subject, body_html, body_text) sends email via SMTP",
        "notify_jorb_paused(jorb) sends notification email when jorb pauses for approval",
        "notify_jorb_complete(jorb) sends notification email when jorb completes",
        "DIGEST_EMAIL_TO environment variable for recipient address",
        "Graceful handling of SMTP failures (log, don't crash)",
        "Unit tests with mocked SMTP verify email formatting"
      ],
      "priority": 66,
      "passes": true,
      "notes": "No direct dependencies. Used for daily digest and notifications."
    },
    {
      "id": "frank_bot-00067",
      "title": "Implement daily digest email for jorbs",
      "acceptanceCriteria": [
        "send_daily_digest(jorbs) method in EmailService",
        "Digest includes: active jorbs summary, completed jorbs, all interactions log, agent reasoning highlights, costs",
        "Interactions grouped by jorb with timestamps",
        "Agent reasoning shown for key decisions",
        "Costs include token count and SMS count per jorb",
        "HTML formatted for readability with text fallback",
        "DIGEST_TIME environment variable (e.g., '08:00') for send time",
        "Unit tests verify digest content generation"
      ],
      "priority": 67,
      "passes": true,
      "notes": "Depends on frank_bot-00066. Daily summary of jorb activity."
    },
    {
      "id": "frank_bot-00068",
      "title": "Create background event loop for jorb system",
      "acceptanceCriteria": [
        "Background asyncio task started with Starlette app lifecycle",
        "Listens for incoming Telegram messages via Telethon callback",
        "Processes debounced messages when timers fire",
        "Runs heartbeat every hour: check stale jorbs, scheduled actions",
        "Sends daily digest at configured time",
        "Graceful shutdown on SIGTERM/SIGINT",
        "Errors logged but don't crash the background loop",
        "Integration test verifies background task starts and processes events"
      ],
      "priority": 68,
      "passes": true,
      "notes": "Depends on frank_bot-00062, frank_bot-00063, frank_bot-00067. Orchestrates jorb event processing."
    },
    {
      "id": "frank_bot-00069",
      "title": "Add jorb environment variables to config and documentation",
      "acceptanceCriteria": [
        "config.py updated with all jorb-related settings",
        "Settings: OPENAI_API_KEY, AGENT_SPEND_LIMIT, DEBOUNCE_TELEGRAM_SECONDS, DEBOUNCE_SMS_SECONDS",
        "Settings: SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD, DIGEST_EMAIL_TO, DIGEST_TIME",
        "Settings: JORBS_DB_PATH, JORBS_PROGRESS_LOG, CONTEXT_RESET_DAYS",
        ".env.example updated with all new environment variables",
        "README.md updated with jorbs configuration section",
        "Defaults documented: gpt-5.2 model, $100 spend limit, 3-day context reset"
      ],
      "priority": 69,
      "passes": true,
      "notes": "Can be done early as it's documentation/config only. Blocks deployment."
    },
    {
      "id": "frank_bot-00070",
      "title": "Create web dashboard jorbs card component",
      "acceptanceCriteria": [
        "web/src/lib/api.ts extended with getJorbs(), getJorb(id), approveJorb(id, decision), cancelJorb(id, reason)",
        "web/src/components/jorbs-card.ts created as Lit component",
        "Card fetches and displays jorbs from GET /jorbs",
        "Status badges color-coded: planning (gray), running (blue), paused (yellow), complete (green), failed (red), cancelled (gray)",
        "Click on jorb expands to show: plan summary, contacts, recent messages, progress",
        "Paused jorbs show approve/cancel buttons with input for decision/reason",
        "Filter by status dropdown (open, closed, all)",
        "Auto-refresh toggle for polling active jorbs"
      ],
      "priority": 70,
      "passes": true,
      "notes": "Depends on frank_bot-00059, frank_bot-00034. Web UI for jorb management."
    },
    {
      "id": "frank_bot-00071",
      "title": "Add jorb message thread view to web dashboard",
      "acceptanceCriteria": [
        "Clicking jorb in jorbs-card opens message thread view",
        "Thread displays full conversation history from GET /jorbs/{id}/messages",
        "Messages styled differently by direction (inbound left, outbound right)",
        "Channel indicated with icon (SMS, Telegram, email)",
        "Agent reasoning shown as collapsible detail on outbound messages",
        "Timestamps in human-readable format with relative time",
        "Auto-scroll to newest messages",
        "Load more button for pagination"
      ],
      "priority": 71,
      "passes": true,
      "notes": "Depends on frank_bot-00070. Detailed jorb conversation view."
    },
    {
      "id": "frank_bot-00072",
      "title": "Write integration tests for jorb end-to-end flow",
      "acceptanceCriteria": [
        "Test: Create jorb, verify initial message sent, mock reply, verify agent processes",
        "Test: Jorb pauses when policy requires approval, verify pause state",
        "Test: Approve paused jorb, verify agent takes next action",
        "Test: Cancel jorb, verify status updated",
        "Test: Message debouncing combines rapid messages",
        "Test: Context reset generates handoff and updates progress log",
        "Test: Brief me returns accurate activity summary",
        "Tests use mocked OpenAI, Telegram, and SMS services"
      ],
      "priority": 72,
      "passes": true,
      "notes": "Depends on all jorb tasks. Validates complete jorb system."
    },
    {
      "id": "frank_bot-00073",
      "title": "Add schemas/jorb.schema.json for jorb data validation",
      "acceptanceCriteria": [
        "schemas/jorb.schema.json created with Jorb object schema",
        "Required fields: id, name, status, original_plan",
        "Optional fields: contacts, progress_summary, paused_reason, needs_approval_for, awaiting",
        "contacts array items have: identifier (required), channel (required), name (optional)",
        "status enum: planning, running, paused, complete, failed, cancelled",
        "channel enum: telegram, sms, email",
        "JorbMessage schema defined with all message fields",
        "Schema used for validation in create_jorb_action"
      ],
      "priority": 73,
      "passes": true,
      "notes": "Foundation task, can be done early. Defines jorb data structure."
    },
    {
      "id": "frank_bot-00074",
      "title": "Create Telegram message history fetcher for style analysis",
      "acceptanceCriteria": [
        "Add get_all_messages(chat_id, before_date, direction_filter) method to TelegramClientService",
        "Method uses Telethon iter_messages with offset_date parameter to fetch all messages",
        "direction_filter parameter allows fetching only outgoing messages (out=True)",
        "before_date filters to messages before a specific timestamp (default: 2026-01-01)",
        "Method handles pagination internally and returns complete list",
        "Returns list of TelegramMessage objects with full metadata",
        "Unit tests verify message fetching with date and direction filters"
      ],
      "priority": 74,
      "passes": true,
      "notes": "Foundation for Stream A (SEAN.md generation). Required by frank_bot-00075."
    },
    {
      "id": "frank_bot-00075",
      "title": "Implement style analysis function for Sean's voice patterns",
      "acceptanceCriteria": [
        "Create services/style_analyzer.py with StyleAnalyzer class",
        "fetch_authentic_messages(chat_id) fetches outgoing messages before 2026-01-01 via TelegramClientService",
        "analyze_patterns(messages) analyzes messages across categories: hedging, disagreement, pausing, resuming, revision, acknowledgment, action_requests, follow_ups, tone_markers",
        "Each category extracts patterns with example quotes from actual messages",
        "Hedging patterns: uncertainty expressions ('I suppose', 'maybe', 'Like a week...')",
        "Acknowledgment patterns: how Sean confirms ('Yep', 'Mk', 'thank you!')",
        "Tone markers: punctuation patterns, capitalization habits, typo tolerance",
        "Returns StyleAnalysisResult dataclass with all pattern categories",
        "Unit tests verify pattern extraction with sample messages"
      ],
      "priority": 75,
      "passes": true,
      "notes": "Depends on frank_bot-00074. Core analysis logic for Stream A."
    },
    {
      "id": "frank_bot-00076",
      "title": "Create SEAN.md generator from style analysis results",
      "acceptanceCriteria": [
        "Add generate_sean_md(analysis_result) function to StyleAnalyzer",
        "Output is structured Markdown with ~5 pages of content",
        "Includes executive summary of Sean's communication style",
        "Detailed sections for each pattern category with extracted examples",
        "Anti-patterns section documenting what NOT to do (no emojis, no markdown, no verbose confirmations)",
        "Sample transformations section: 'Instead of X, write Y' examples",
        "Written in declarative, prescriptive language in neutral third person",
        "Returns complete Markdown string ready for file write",
        "Unit tests verify output structure and required sections"
      ],
      "priority": 76,
      "passes": true,
      "notes": "Depends on frank_bot-00075. Generates the SEAN.md style guide document."
    },
    {
      "id": "frank_bot-00077",
      "title": "Add action to generate and send SEAN.md via Telegram",
      "acceptanceCriteria": [
        "Create actions/style_capture.py with generate_sean_md_action(arguments)",
        "Action fetches Magic conversation history (chat_id: @MagicConciergeBot)",
        "Action runs style analysis and generates SEAN.md content",
        "Action sends generated content to @SeanReardon via Telegram",
        "If content exceeds Telegram message limit, splits into multiple messages",
        "Returns JSON with success status, message_count, and preview of content",
        "GET /actions/style/generate route added to server/routes.py",
        "Route protected by existing API key authentication"
      ],
      "priority": 77,
      "passes": true,
      "notes": "Depends on frank_bot-00076. Delivery mechanism for SEAN.md to Sean."
    },
    {
      "id": "frank_bot-00078",
      "title": "Create sean-voice personality file",
      "acceptanceCriteria": [
        "Create personalities/sean-voice.json following existing personality schema",
        "Set id: 'sean-voice', name: 'Sean's Voice'",
        "Communication style: informal, typos_ok, no emojis, no markdown",
        "Verbosity: very_concise (prefer short responses like 'Yep', 'Mk')",
        "Preamble references SEAN.md patterns document",
        "Guidelines include: avoid verbose confirmations, allow natural typos, use casual punctuation",
        "Examples section includes transformations from formal to Sean-style",
        "Model preferences: temperature 0.8 for more natural variation",
        "Personality loads successfully via PersonalityLoader"
      ],
      "priority": 78,
      "passes": true,
      "notes": "Depends on frank_bot-00076 conceptually (needs to match SEAN.md patterns). Used by Stream C."
    },
    {
      "id": "frank_bot-00079",
      "title": "Modify Telegram listener to process outgoing messages",
      "acceptanceCriteria": [
        "Update _dispatch_to_handlers in telegram_client.py to NOT skip outgoing messages (remove if event.out: return)",
        "Add new field is_self_sent: bool to event dispatch context",
        "For outgoing messages, check if message exists in jorb_messages table (by timestamp and content similarity)",
        "Matching criteria: timestamp within 5 seconds AND content substring match",
        "If found in jorb_messages \u2192 skip (sent by frank_bot)",
        "If NOT found \u2192 dispatch to handlers with is_human_intervention=True flag",
        "Unit tests verify: frank_bot messages are skipped, Sean's direct messages are processed"
      ],
      "priority": 79,
      "passes": true,
      "notes": "Stream B foundation. Requires access to jorb_messages table for deduplication."
    },
    {
      "id": "frank_bot-00080",
      "title": "Update switchboard to handle human intervention flag",
      "acceptanceCriteria": [
        "Add is_human_intervention: bool parameter to Switchboard.route() method",
        "When is_human_intervention=True, routing still identifies the jorb but with special handling",
        "RoutingDecision includes new field: is_human_intervention: bool = False",
        "If message matches a jorb AND is_human_intervention, set confidence='high' (Sean knows what he's doing)",
        "Update switchboard system prompt to explain human intervention semantics",
        "Unit tests verify routing with and without is_human_intervention flag"
      ],
      "priority": 80,
      "passes": true,
      "notes": "Depends on frank_bot-00079. Extends switchboard for Stream B."
    },
    {
      "id": "frank_bot-00081",
      "title": "Update AgentRunner to handle Sean's direct messages",
      "acceptanceCriteria": [
        "Add is_human_intervention field to IncomingEvent dataclass",
        "In process_incoming_message, when is_human_intervention=True and jorb_id matched:",
        "Store message with direction='outbound' and sender='sean_direct' marker",
        "Do NOT call jorb session for LLM response (Sean already said something)",
        "Update jorb progress_summary: 'Sean intervened directly: [message preview]'",
        "If message content suggests closure ('thanks', 'done', 'perfect'), consider updating status",
        "Add new action_taken value: 'human_intervention_recorded'",
        "Unit tests verify Sean's messages are stored without triggering LLM response"
      ],
      "priority": 81,
      "passes": true,
      "notes": "Depends on frank_bot-00079, frank_bot-00080. Completes Stream B core logic."
    },
    {
      "id": "frank_bot-00082",
      "title": "Add trusted sender detection for catch-up jorb creation",
      "acceptanceCriteria": [
        "Add get_all_contacts_from_jorbs() method to JorbStorage",
        "Returns set of all unique contact identifiers across all jorbs (any status)",
        "Add is_trusted_sender(sender) method to AgentRunner using JorbStorage contacts",
        "Sender is trusted if their identifier matches any jorb contact (normalized comparison)",
        "Normalization handles: @username variations, phone number formats, email case",
        "Unit tests verify trusted sender detection with various identifier formats"
      ],
      "priority": 82,
      "passes": true,
      "notes": "Stream C foundation. Required by frank_bot-00083."
    },
    {
      "id": "frank_bot-00083",
      "title": "Implement catch-up jorb creation for in-flight tasks",
      "acceptanceCriteria": [
        "In AgentRunner.process_incoming_message, after routing returns jorb_id=None:",
        "Check if sender is_trusted_sender AND routing.might_be_new_jorb=True",
        "If both true, create catch-up jorb automatically:",
        "Jorb name: 'Catch-up: [first 30 chars of message content]'",
        "Jorb status: 'running'",
        "Jorb plan: 'Recover context for in-flight task. Original message: [content]'",
        "Jorb personality: 'sean-voice'",
        "Jorb contacts: sender's identifier",
        "Store the incoming message as first inbound message",
        "Kick off jorb with special first_action: ask for context",
        "Return ProcessingResult with jorb_id and action_taken='catch_up_created'"
      ],
      "priority": 83,
      "passes": true,
      "notes": "Depends on frank_bot-00078, frank_bot-00082. Core Stream C logic."
    },
    {
      "id": "frank_bot-00084",
      "title": "Add catch-up jorb kickoff message in sean-voice style",
      "acceptanceCriteria": [
        "Update JorbSession.kickoff() to detect catch-up jorbs (plan contains 'Recover context')",
        "For catch-up jorbs, override first message to ask for context in Sean's style",
        "Example message: 'Hey sorry I've lost track of this - can you remind me where we left off?'",
        "Message varies slightly using personality temperature for natural feel",
        "After sending, set jorb awaiting to 'context_recovery'",
        "Unit tests verify catch-up kickoff uses correct style and sets awaiting"
      ],
      "priority": 84,
      "passes": true,
      "notes": "Depends on frank_bot-00078, frank_bot-00083. Completes catch-up jorb flow."
    },
    {
      "id": "frank_bot-00085",
      "title": "Add unknown sender handling for non-trusted senders",
      "acceptanceCriteria": [
        "In AgentRunner, if routing.jorb_id=None AND routing.might_be_new_jorb=True AND sender NOT trusted:",
        "Do NOT create catch-up jorb (could be spam or wrong number)",
        "Flag message for human review instead of auto-jorbing",
        "Send Telegram notification to Sean: 'Unknown sender [identifier] sent: [preview]. Create jorb?'",
        "Return ProcessingResult with action_taken='flagged_for_review'",
        "Add GET /jorbs/pending-reviews route that lists flagged messages",
        "Unit tests verify unknown senders are flagged, not auto-jorbed"
      ],
      "priority": 85,
      "passes": true,
      "notes": "Depends on frank_bot-00082, frank_bot-00083. Prevents spam from creating jorbs."
    },
    {
      "id": "frank_bot-00086",
      "title": "Update jorb session to learn from Sean's direct messages",
      "acceptanceCriteria": [
        "JorbSession receives list of recent messages including sean_direct ones",
        "When building context, sean_direct messages are labeled as 'guidance from principal'",
        "Jorb session prompt instructs: 'Learn from Sean's direct messages - they show preferred phrasing'",
        "Add progress.learnings extraction when Sean's style differs from frank_bot's",
        "Record learnings via ProgressLog with subject='Sean's communication style'",
        "Unit tests verify sean_direct messages influence session decisions"
      ],
      "priority": 86,
      "passes": true,
      "notes": "Depends on frank_bot-00081. Enhances learning from Stream B."
    },
    {
      "id": "frank_bot-00087",
      "title": "Add CLI script for SEAN.md generation",
      "acceptanceCriteria": [
        "Create scripts/generate_sean_md.py as standalone CLI script",
        "Script can be run: poetry run python scripts/generate_sean_md.py",
        "Accepts optional --chat-id argument (defaults to @MagicConciergeBot)",
        "Accepts optional --before-date argument (defaults to 2026-01-01)",
        "Accepts optional --output argument (defaults to ./SEAN.md)",
        "Displays progress: 'Fetching messages... Found X messages... Analyzing... Done!'",
        "Writes SEAN.md to specified output path",
        "Optionally sends to @SeanReardon with --send flag",
        "Handles errors gracefully with clear messages"
      ],
      "priority": 87,
      "passes": true,
      "notes": "Depends on frank_bot-00076. Provides manual trigger for SEAN.md generation."
    },
    {
      "id": "frank_bot-00088",
      "title": "Add integration tests for Sean voice capture flow",
      "acceptanceCriteria": [
        "Test: Style analyzer fetches messages before cutoff date only",
        "Test: Style analyzer extracts hedging patterns from sample messages",
        "Test: SEAN.md generator produces all required sections",
        "Test: sean-voice personality loads and formats correctly",
        "Test: Jorbs using sean-voice produce informal, concise messages",
        "Tests use mocked Telegram messages for consistent testing",
        "All tests pass in CI"
      ],
      "priority": 88,
      "passes": true,
      "notes": "Depends on frank_bot-00074 through frank_bot-00078. Validates Stream A."
    },
    {
      "id": "frank_bot-00089",
      "title": "Add integration tests for human intervention flow",
      "acceptanceCriteria": [
        "Test: Telegram listener detects outgoing messages not in jorb_messages",
        "Test: Sean's direct messages route with is_human_intervention=True",
        "Test: Sean's messages are stored without triggering LLM response",
        "Test: Jorb progress is updated with intervention note",
        "Test: Jorb session learns from sean_direct messages",
        "Tests use mocked Telegram client and jorb storage",
        "All tests pass in CI"
      ],
      "priority": 89,
      "passes": true,
      "notes": "Depends on frank_bot-00079 through frank_bot-00081, frank_bot-00086. Validates Stream B."
    },
    {
      "id": "frank_bot-00090",
      "title": "Add integration tests for catch-up jorb flow",
      "acceptanceCriteria": [
        "Test: Trusted sender with unmatched message creates catch-up jorb",
        "Test: Catch-up jorb uses sean-voice personality",
        "Test: Catch-up kickoff message asks for context in Sean's style",
        "Test: Unknown sender with unmatched message is flagged, not jorbed",
        "Test: Magic's response to catch-up updates jorb plan with context",
        "Tests use mocked OpenAI, Telegram, and jorb storage",
        "All tests pass in CI"
      ],
      "priority": 90,
      "passes": true,
      "notes": "Depends on frank_bot-00082 through frank_bot-00085. Validates Stream C."
    },
    {
      "id": "frank_bot-00091",
      "title": "Create androidPhoneGetScreen action with screenshot and XML parsing",
      "acceptanceCriteria": [
        "actions/android_phone.py created (rename from android.py) with get_screen_action(arguments)",
        "Action returns base64-encoded PNG screenshot",
        "Action returns raw accessibility XML from uiautomator dump",
        "Action returns parsed list of clickable elements with coordinates, text, and content_desc",
        "Each clickable element includes: text, content_desc, resource_id, center_x, center_y, bounds",
        "GET /actions/androidPhone/getScreen route added to server/routes.py",
        "Route returns JSON with screenshot_base64, xml, and clickable_elements fields",
        "Unit tests verify screenshot capture and XML parsing"
      ],
      "priority": 91,
      "passes": true,
      "notes": "Foundation for LLM-in-the-loop pattern. Uses existing services/android_client.py. Blocking for frank_bot-00092."
    },
    {
      "id": "frank_bot-00092",
      "title": "Create AndroidPhoneRunner service with LLM loop orchestration",
      "acceptanceCriteria": [
        "services/android_phone_runner.py created with AndroidPhoneRunner class",
        "run_task(task_prompt, max_steps=20) async method implements LLM loop",
        "Each step: capture screen state (XML + screenshot) via get_screen_action",
        "Send state + task_prompt to LLM, receive action decision (tap, type, swipe, done, error)",
        "Execute decided action via AndroidClient methods",
        "Loop continues until LLM returns done=True or max_steps reached",
        "Track and return token usage and cost estimate per run",
        "Uses configurable LLM model (default: gpt-4-vision-preview or claude-3-opus)",
        "ANDROID_LLM_MODEL and ANDROID_LLM_API_KEY environment variables added to config",
        "Unit tests with mocked LLM responses verify loop execution"
      ],
      "priority": 92,
      "passes": true,
      "notes": "Depends on frank_bot-00091. Core LLM-in-the-loop orchestrator. Blocking for frank_bot-00094, frank_bot-00095."
    },
    {
      "id": "frank_bot-00093",
      "title": "Create base prompt template for Android phone control",
      "acceptanceCriteria": [
        "prompts/androidPhone/_base.md created with common instructions",
        "Template explains screen state format (XML structure, clickable elements)",
        "Template defines action response JSON schema: {action, params?, done, reasoning}",
        "Action types documented: tap(x, y), type(text), swipe(direction), press_key(key), wait(seconds), done, error",
        "Best practices section: wait after actions, verify UI changes, handle loading states",
        "Error handling guidance: what to do when element not found, app crashes, unexpected screens",
        "Template uses clear, structured format suitable for vision-capable LLMs",
        "AndroidPhoneRunner loads and includes _base.md in all prompts"
      ],
      "priority": 93,
      "passes": true,
      "notes": "Depends on frank_bot-00092. Shared prompt foundation. Blocking for frank_bot-00094, frank_bot-00095."
    },
    {
      "id": "frank_bot-00094",
      "title": "Create thermostat-setRange prompt template",
      "acceptanceCriteria": [
        "prompts/androidPhone/thermostat-setRange.md created",
        "Template specifies goal: set thermostat to specific temperature range",
        "Parameters section: low_temp (int), high_temp (int)",
        "App information: package com.google.android.apps.chromecast.app (Google Home)",
        "Entry point workflow: launch Google Home -> navigate to thermostat device",
        "Step-by-step workflow for adjusting temperature range",
        "Success criteria: both temperatures set and verified on screen",
        "Known UI patterns: temperature controls, slider elements, save/apply buttons",
        "Error handling: thermostat offline, app not installed, wrong screen navigation"
      ],
      "priority": 94,
      "passes": true,
      "notes": "Depends on frank_bot-00093. MVP thermostat control template. Blocking for frank_bot-00096."
    },
    {
      "id": "frank_bot-00095",
      "title": "Create thermostat-getStatus prompt template",
      "acceptanceCriteria": [
        "prompts/androidPhone/thermostat-getStatus.md created",
        "Template specifies goal: read current thermostat status",
        "Parameters section: none required",
        "App information: package com.google.android.apps.chromecast.app (Google Home)",
        "Entry point workflow: launch Google Home -> navigate to thermostat device",
        "Data extraction workflow: read current temp, target temp, mode (heat/cool/auto), humidity if shown",
        "Success criteria: all status values captured from screen",
        "Output format: JSON with current_temp, target_low, target_high, mode, humidity",
        "Known UI patterns: temperature display elements, mode indicators"
      ],
      "priority": 95,
      "passes": true,
      "notes": "Depends on frank_bot-00093. MVP thermostat status template. Blocking for frank_bot-00097."
    },
    {
      "id": "frank_bot-00096",
      "title": "Implement androidPhone_thermostat_setRange action",
      "acceptanceCriteria": [
        "actions/android_phone.py extended with thermostat_set_range_action(arguments)",
        "Action accepts low_temp and high_temp parameters (integers)",
        "Validates temperature range (e.g., 60-85\u00b0F reasonable bounds)",
        "Loads thermostat-setRange.md prompt and formats with parameters",
        "Calls AndroidPhoneRunner.run_task() with formatted prompt",
        "Returns JSON with success, final_low_temp, final_high_temp, steps_taken, tokens_used",
        "GET /actions/androidPhone/thermostat/setRange route added with query params low_temp, high_temp",
        "Integration test with mocked LLM verifies action flow"
      ],
      "priority": 96,
      "passes": true,
      "notes": "Depends on frank_bot-00092, frank_bot-00094. MVP action for setting thermostat."
    },
    {
      "id": "frank_bot-00097",
      "title": "Implement androidPhone_thermostat_getStatus action",
      "acceptanceCriteria": [
        "actions/android_phone.py extended with thermostat_get_status_action(arguments)",
        "Action requires no parameters",
        "Loads thermostat-getStatus.md prompt",
        "Calls AndroidPhoneRunner.run_task() with prompt",
        "Returns JSON with current_temp, target_low, target_high, mode, humidity, steps_taken, tokens_used",
        "GET /actions/androidPhone/thermostat/getStatus route added",
        "Handles case where thermostat is offline or unreachable",
        "Integration test with mocked LLM verifies status extraction"
      ],
      "priority": 97,
      "passes": true,
      "notes": "Depends on frank_bot-00092, frank_bot-00095. MVP action for reading thermostat status."
    },
    {
      "id": "frank_bot-00098",
      "title": "Add health check endpoint for Android phone connection",
      "acceptanceCriteria": [
        "GET /actions/androidPhone/health route added to server/routes.py",
        "Returns JSON with connected, device_model, android_version, battery_level, wifi_ssid",
        "Checks ADB connection status via AndroidClient.check_connection()",
        "Battery level retrieved via adb shell dumpsys battery",
        "WiFi SSID retrieved via adb shell dumpsys wifi",
        "Returns clear error message if device not reachable",
        "Endpoint can be called without API key (status check)",
        "Health check result cached for 30 seconds to reduce ADB overhead"
      ],
      "priority": 98,
      "passes": true,
      "notes": "Standalone diagnostic endpoint. No blocking dependencies."
    },
    {
      "id": "frank_bot-00099",
      "title": "Create AndroidMaintenanceService for device upkeep",
      "acceptanceCriteria": [
        "services/android_maintenance.py created with AndroidMaintenanceService class",
        "check_app_updates() checks Play Store for pending updates, returns list of apps needing update",
        "install_app_updates() installs available updates via adb shell pm commands",
        "check_security_patch() reads current security patch level, compares to latest known",
        "clear_caches() clears app caches if storage below threshold",
        "get_storage_info() returns internal storage used/free percentages",
        "reboot_device() safely reboots via adb reboot",
        "All methods are async and use AndroidClient",
        "Unit tests verify each maintenance operation"
      ],
      "priority": 99,
      "passes": true,
      "notes": "Foundation for maintenance features. Blocking for frank_bot-00100, frank_bot-00101."
    },
    {
      "id": "frank_bot-00100",
      "title": "Add maintenance routes and actions for Android phone",
      "acceptanceCriteria": [
        "actions/android_phone.py extended with maintenance actions",
        "update_apps_action() triggers app update process, returns apps updated",
        "check_security_action() returns current and latest security patch info",
        "reboot_action() reboots device with confirmation parameter",
        "GET /actions/androidPhone/maintenance/updateApps route added",
        "GET /actions/androidPhone/maintenance/checkSecurity route added",
        "GET /actions/androidPhone/maintenance/reboot route added (requires confirm=true param)",
        "All routes protected by API key authentication",
        "Integration tests verify maintenance action flows"
      ],
      "priority": 100,
      "passes": true,
      "notes": "Depends on frank_bot-00099. Exposes maintenance functionality via HTTP."
    },
    {
      "id": "frank_bot-00101",
      "title": "Create maintenance prompt templates",
      "acceptanceCriteria": [
        "prompts/androidPhone/maintenance-updateApps.md created",
        "Template workflow: open Play Store -> My Apps -> Update All",
        "prompts/androidPhone/maintenance-checkStorage.md created",
        "Template workflow: open Settings -> Storage -> read values",
        "prompts/androidPhone/maintenance-clearCache.md created",
        "Template workflow: open Settings -> Apps -> clear cache for top space-consuming apps",
        "Each template includes success criteria and error handling",
        "Templates integrated with AndroidMaintenanceService methods"
      ],
      "priority": 101,
      "passes": true,
      "notes": "Depends on frank_bot-00099. Prompt templates for LLM-driven maintenance tasks."
    },
    {
      "id": "frank_bot-00102",
      "title": "Add scheduled maintenance jorb for monthly device upkeep",
      "acceptanceCriteria": [
        "Monthly maintenance jorb defined in services/background_loop.py",
        "Scheduled for 1st of month at 3 AM (configurable via ANDROID_MAINTENANCE_CRON)",
        "Jorb executes: check_security, check_app_updates, install_updates if available, clear_caches if needed",
        "Results sent to Sean via Telegram with summary report",
        "Report includes: apps updated, security status, storage freed, any errors",
        "Jorb skipped if device not connected (logs warning, retries next day)",
        "config.py updated with ANDROID_MAINTENANCE_CRON setting",
        "Integration test verifies scheduled execution"
      ],
      "priority": 102,
      "passes": true,
      "notes": "Depends on frank_bot-00099, frank_bot-00100, frank_bot-00068 (background loop). Monthly maintenance automation."
    },
    {
      "id": "frank_bot-00103",
      "title": "Add weekly health check jorb for Android phone",
      "acceptanceCriteria": [
        "Weekly health check defined in services/background_loop.py",
        "Scheduled for Sunday at 4 AM (configurable via ANDROID_HEALTH_CHECK_CRON)",
        "Check includes: device connection, battery health, WiFi connectivity, test app launch",
        "Only sends Telegram notification if issues detected",
        "Notification includes specific issues and suggested actions",
        "Successful checks logged but not notified",
        "config.py updated with ANDROID_HEALTH_CHECK_CRON setting",
        "Integration test verifies health check execution and notification logic"
      ],
      "priority": 103,
      "passes": true,
      "notes": "Depends on frank_bot-00098, frank_bot-00068 (background loop). Weekly health monitoring."
    },
    {
      "id": "frank_bot-00104",
      "title": "Update OpenAPI spec with Android phone endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes GET /actions/androidPhone/getScreen endpoint",
        "openapi/spec.json includes GET /actions/androidPhone/health endpoint",
        "openapi/spec.json includes GET /actions/androidPhone/thermostat/setRange endpoint",
        "openapi/spec.json includes GET /actions/androidPhone/thermostat/getStatus endpoint",
        "openapi/spec.json includes maintenance endpoints (updateApps, checkSecurity, reboot)",
        "Response schemas accurately describe return types including nested objects",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json",
        "Endpoint descriptions explain LLM-in-the-loop nature and token costs"
      ],
      "priority": 104,
      "passes": true,
      "notes": "Depends on frank_bot-00096, frank_bot-00097, frank_bot-00100. Documents all Android phone APIs. Maintenance endpoints not yet added - depends on 00100."
    },
    {
      "id": "frank_bot-00105",
      "title": "Add Android phone configuration to environment and documentation",
      "acceptanceCriteria": [
        "config.py updated with: ANDROID_ADB_HOST, ANDROID_ADB_PORT, ANDROID_LLM_MODEL, ANDROID_LLM_API_KEY",
        "config.py updated with: ANDROID_MAINTENANCE_CRON, ANDROID_HEALTH_CHECK_CRON",
        ".env.example updated with all Android phone environment variables",
        "README.md updated with Android phone setup section",
        "Documentation includes: device requirements (rooted, ADB enabled), network setup, initial configuration",
        "Documentation explains LLM model options and cost considerations",
        "Documentation lists supported apps and their package names"
      ],
      "priority": 105,
      "passes": true,
      "notes": "Configuration and documentation task. Can be done in parallel with implementation."
    },
    {
      "id": "frank_bot-00106",
      "title": "Write integration tests for Android phone thermostat flow",
      "acceptanceCriteria": [
        "Test: getScreen returns valid screenshot and parsed elements",
        "Test: thermostat_setRange executes LLM loop and sets temperature",
        "Test: thermostat_getStatus extracts status values correctly",
        "Test: LLM loop respects max_steps limit",
        "Test: Error handling when device disconnected mid-task",
        "Test: Token tracking accumulates correctly across steps",
        "Tests use mocked AndroidClient and LLM responses",
        "All tests pass in CI"
      ],
      "priority": 106,
      "passes": true,
      "notes": "Depends on frank_bot-00096, frank_bot-00097. Validates MVP thermostat functionality."
    },
    {
      "id": "frank_bot-00107",
      "title": "Add rate limiting for Android phone actions",
      "acceptanceCriteria": [
        "Rate limiter applied to all /actions/androidPhone/* routes",
        "Default limits: 10 requests per minute, 100 requests per hour",
        "Limits configurable via ANDROID_RATE_LIMIT_MINUTE and ANDROID_RATE_LIMIT_HOUR",
        "Rate limit exceeded returns 429 Too Many Requests with retry-after header",
        "Rate limits tracked per API key",
        "Long-running tasks (thermostat control) exempt from per-minute limit but count toward hourly",
        "Unit tests verify rate limiting behavior"
      ],
      "priority": 107,
      "passes": true,
      "notes": "Security feature. Can be implemented after core functionality complete."
    },
    {
      "id": "frank_bot-00108",
      "title": "Add audit logging for Android phone actions",
      "acceptanceCriteria": [
        "All Android phone actions logged to ./data/android_audit.log",
        "Log entries include: timestamp, action, parameters, result, tokens_used, duration_ms",
        "Sensitive data (screenshots) not logged in full, only metadata",
        "Log rotation: daily files, keep 30 days",
        "GET /actions/androidPhone/audit route returns recent audit entries",
        "Audit endpoint protected by API key",
        "Log format is JSON lines for easy parsing"
      ],
      "priority": 108,
      "passes": true,
      "notes": "Security and debugging feature. Provides visibility into automated actions."
    },
    {
      "id": "frank_bot-00109",
      "title": "Create capabilities reference generator for jorb prompts",
      "acceptanceCriteria": [
        "New file services/jorb_capabilities.py with generate_capabilities_reference() function",
        "Function introspects FrankAPI (from meta/api.py) and returns a markdown string documenting all frank.* namespaces, methods, parameters, and return types",
        "Output includes method signatures with parameter names and types extracted from docstrings/annotations",
        "Output includes brief usage examples for each namespace (calendar, contacts, sms, telegram, swarm, android, time, ups)",
        "Function uses meta/introspection.py generate_meta_documentation() or similar reflection rather than hardcoding capability lists",
        "Unit test in tests/ verifies the function returns valid markdown containing all current namespace names"
      ],
      "priority": 109,
      "passes": true,
      "notes": "Blocks frank_bot-00112 (new system prompt). Uses existing introspection infrastructure from meta/introspection.py. This ensures jorb prompts always reflect current FrankAPI capabilities without manual updates."
    },
    {
      "id": "frank_bot-00110",
      "title": "Add frank.android namespace to FrankAPI",
      "acceptanceCriteria": [
        "New AndroidNamespace class in meta/api.py with task_do(goal, app=None), task_get(task_id), and task_cancel(task_id) methods",
        "Methods wrap the async action handlers from actions/android_phone.py (task_do_action, task_get_action, task_cancel_action) using the same sync pattern as other namespaces",
        "FrankAPI.__init__ registers self.android = AndroidNamespace()",
        "meta/introspection.py generate_meta_documentation() includes the android namespace in its output",
        "Unit test verifies frank.android namespace exists and has expected methods",
        "Existing FrankAPI tests continue to pass"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Blocks frank_bot-00113 (script execution in agent runner). Follows exact same pattern as existing namespaces (CalendarNamespace, TelegramNamespace, etc.) in meta/api.py."
    },
    {
      "id": "frank_bot-00111",
      "title": "Add script_results field to JorbStorage schema",
      "acceptanceCriteria": [
        "Jorb dataclass in services/jorb_storage.py gains script_results: list[dict] field (default empty list)",
        "SQLite schema includes script_results column (JSON text, default '[]')",
        "Schema migration handles existing rows that lack the column (ALTER TABLE ADD COLUMN with default)",
        "New method add_script_result(jorb_id, result_dict) appends to the list and persists",
        "New method get_script_results(jorb_id, limit=20) returns most recent N results",
        "Each script result dict contains: script, result, success (bool), timestamp",
        "Unit tests verify add/get round-trip and limit parameter"
      ],
      "priority": 111,
      "passes": true,
      "notes": "Blocks frank_bot-00113 (script execution in agent runner). The script_results list is passed to the LLM as context so it can see what scripts have been run and their outputs."
    },
    {
      "id": "frank_bot-00112",
      "title": "Rewrite jorb session system prompt for script-generating agents",
      "acceptanceCriteria": [
        "prompts/jorb_session_system.md updated with new template that includes {{CAPABILITIES_REFERENCE}} placeholder",
        "Template instructs LLM to output JSON with fields: reasoning, script, await_reply, done, pause, pause_reason, result",
        "Template includes {{SCRIPT_RESULTS}} placeholder for execution history",
        "Template retains existing placeholders: {{PERSONALITY_SECTION}}, {{JORB_CONTEXT}}, {{MESSAGE_HISTORY}}, {{CURRENT_EVENT}}, {{POLICY}}",
        "Template includes clear decision guidelines: when to use script vs done vs pause vs await_reply",
        "Template includes 2-3 inline examples showing script generation for different capability domains (calendar query, telegram send with await, android task)",
        "services/jorb_session.py updated to inject capabilities reference (from frank_bot-00109) and script_results into the prompt template"
      ],
      "priority": 112,
      "passes": true,
      "notes": "Depends on frank_bot-00109 (capabilities reference generator). Blocks frank_bot-00113. The prompt must preserve backward compatibility by still supporting the personality system and message history injection. See prompts/unified-jorbs-design.md for reference format."
    },
    {
      "id": "frank_bot-00113",
      "title": "Update JorbSession to parse new script-based JSON response format",
      "acceptanceCriteria": [
        "JorbAction dataclass in services/jorb_session.py updated or replaced with new fields: script (str|None), await_reply (bool), done (bool), pause (bool), pause_reason (str|None), result (dict|None), reasoning (str)",
        "JorbSessionResponse updated to carry the new JorbAction shape",
        "JorbSession._parse_response() handles the new JSON format, extracting script and flow-control fields",
        "Graceful handling of malformed LLM output (missing fields get sensible defaults, invalid JSON triggers retry or error)",
        "Unit tests verify parsing of valid JSON for each action type: script-with-await, script-without-await, done, pause, no-action"
      ],
      "priority": 113,
      "passes": true,
      "notes": "Depends on frank_bot-00112 (new system prompt). Blocks frank_bot-00114. This task only changes the parsing layer in jorb_session.py - actual script execution is handled in frank_bot-00114."
    },
    {
      "id": "frank_bot-00114",
      "title": "Add script execution to AgentRunner via FrankAPI executor",
      "acceptanceCriteria": [
        "AgentRunner in services/agent_runner.py gains _execute_script(jorb, script_str) method",
        "Method executes the script string using meta/executor.py infrastructure with FrankAPI context injected",
        "Script results (success or error) are stored via JorbStorage.add_script_result()",
        "Execution timeout of 300 seconds per script (configurable)",
        "Script errors are captured and stored (not raised) so the LLM can see the error and decide how to handle it",
        "Unit tests verify successful script execution stores result, and failed script stores error info"
      ],
      "priority": 114,
      "passes": true,
      "notes": "Depends on frank_bot-00110 (android namespace), frank_bot-00111 (script_results storage), frank_bot-00113 (new action format). Blocks frank_bot-00115. The executor must handle the script as a Python expression (e.g., 'frank.calendar.events(day=\"2026-02-05\")') and return the result dict."
    },
    {
      "id": "frank_bot-00115",
      "title": "Implement sync/async agent loop in AgentRunner",
      "acceptanceCriteria": [
        "AgentRunner.process_jorb_event() implements a loop: invoke LLM  parse action  execute  decide next step",
        "Sync scripts (await_reply=false, done=false): execute script, feed result back to LLM immediately, continue loop",
        "Async scripts (await_reply=true): execute script (sends message), mark jorb as awaiting human reply, break loop",
        "Done actions: mark jorb complete with result, break loop",
        "Pause actions: mark jorb paused with reason, break loop",
        "No-script no-done no-pause: break loop (safety fallback)",
        "Loop passes script_results history to LLM context on each iteration",
        "Unit tests verify each flow path: sync loop continues, async breaks, done breaks, pause breaks"
      ],
      "priority": 115,
      "passes": true,
      "notes": "Depends on frank_bot-00114 (script execution). Blocks frank_bot-00116, frank_bot-00117. This is the core behavioral change - transforming the single-shot message handler into an iterative agent loop. See prompts/unified-jorbs-design.md execution flow diagram."
    },
    {
      "id": "frank_bot-00116",
      "title": "Add rate limiting for jorb LLM invocation loops",
      "acceptanceCriteria": [
        "AgentRunner enforces max LLM invocations per jorb: 20 per hour, 100 per day",
        "Limits are configurable via constants (MAX_ITERATIONS_PER_HOUR, MAX_ITERATIONS_PER_DAY)",
        "When limit exceeded, jorb is paused with a clear pause_reason explaining the rate limit",
        "Iteration counts tracked per jorb (not global) using timestamps",
        "Rate limit check runs before each LLM invocation in the agent loop",
        "Unit tests verify: under-limit proceeds, at-limit pauses, counts reset after time window"
      ],
      "priority": 116,
      "passes": true,
      "notes": "Depends on frank_bot-00115 (agent loop). Safety feature to prevent runaway LLM loops that could burn through API credits. The existing JorbPolicy already has max_messages_per_hour=20 which provides a model to follow."
    },
    {
      "id": "frank_bot-00117",
      "title": "Integration tests for unified jorb flows",
      "acceptanceCriteria": [
        "Integration test: calendar query jorb - creates jorb, LLM generates frank.calendar.events() script, result returned, jorb completes",
        "Integration test: telegram conversation jorb - creates jorb, LLM sends message via frank.telegram.send(), jorb awaits reply, simulated reply triggers next iteration, jorb completes",
        "Integration test: android phone jorb - creates jorb, LLM calls frank.android.task_do(), polls with frank.android.task_get(), interprets result, jorb completes",
        "Integration test: pause for approval - jorb pauses with reason, jorbApprove resumes processing",
        "Tests use mocked LLM responses (not real API calls) but exercise the full AgentRunner pipeline",
        "All existing jorb tests continue to pass"
      ],
      "priority": 117,
      "passes": true,
      "notes": "Depends on frank_bot-00115 (agent loop), frank_bot-00116 (rate limiting). These tests validate the end-to-end flow described in prompts/unified-jorbs-design.md examples (hotel booking, thermostat). Mock the OpenAI API to return predetermined JSON responses."
    },
    {
      "id": "frank_bot-00118",
      "title": "Add TelegramBotListener class with getUpdates long-polling",
      "acceptanceCriteria": [
        "TelegramBotListener class added to services/telegram_bot.py with __init__(on_message), start_polling(), stop_polling(), _poll_loop(), _get_updates(), _process_update()",
        "_get_updates() calls GET /bot{token}/getUpdates with offset and timeout=3, parses JSON response, updates offset to max(update_id)+1",
        "_process_update() extracts message text, sender username, and chat_id from update dict",
        "_process_update() checks sender against telegram_allowlist and silently drops non-allowlisted senders",
        "_process_update() does NOT apply _is_jorb_contact() gate  all allowlisted messages pass through",
        "start_polling() sets _running=True and creates asyncio task for _poll_loop()",
        "stop_polling() sets _running=False and cancels the poll task",
        "Unit tests verify polling loop processes updates and respects allowlist"
      ],
      "priority": 118,
      "passes": true,
      "notes": "No blocking dependencies on new tasks. Uses existing TelegramBot class in same file for httpx client pattern. This is the foundation for Piece 1  blocks frank_bot-00119, frank_bot-00120, frank_bot-00121."
    },
    {
      "id": "frank_bot-00119",
      "title": "Create telegram_bot_router.py with MessageBuffer and flush callback",
      "acceptanceCriteria": [
        "New file services/telegram_bot_router.py created, mirroring telegram_jorb_router.py pattern",
        "Module-level MessageBuffer instance for debouncing bot messages",
        "Flush callback _on_bot_message_flush(event) creates IncomingEvent with channel='telegram_bot' and calls AgentRunner.process_incoming_message()",
        "initialize_telegram_bot_router() creates TelegramBotListener with the flush callback and starts polling",
        "shutdown_telegram_bot_router() stops polling and flushes pending messages",
        "get_bot_router_status() returns dict with initialized, configured, pending message counts",
        "No _is_jorb_contact() gate  bot messages from allowlisted senders go straight to Switchboard",
        "Unit tests verify flush callback creates correct IncomingEvent with channel='telegram_bot'"
      ],
      "priority": 119,
      "passes": true,
      "notes": "Depends on frank_bot-00118 (TelegramBotListener). Mirrors telegram_jorb_router.py but without the jorb contact gate. Blocks frank_bot-00120."
    },
    {
      "id": "frank_bot-00120",
      "title": "Wire bot listener into BackgroundLoopService lifecycle",
      "acceptanceCriteria": [
        "BackgroundLoopService.start() calls initialize_telegram_bot_router() after Telethon router init",
        "BackgroundLoopService.stop() calls shutdown_telegram_bot_router()",
        "BackgroundLoopService.get_status() includes bot listener status from get_bot_router_status()",
        "Existing Telethon listener continues working unchanged",
        "Bot listener failure does not prevent other services from starting (graceful degradation)",
        "Unit tests verify bot router is initialized on start and shut down on stop"
      ],
      "priority": 120,
      "passes": true,
      "notes": "Depends on frank_bot-00119 (telegram_bot_router). Wires new bot listener into existing lifecycle alongside Telethon router."
    },
    {
      "id": "frank_bot-00121",
      "title": "Add telegram_bot reply channel to agent_runner._send_message()",
      "acceptanceCriteria": [
        "agent_runner._send_message() handles channel='telegram_bot' by routing through TelegramBot.send_notification() (bot API), not Telethon",
        "Bot replies use the chat_id from the original incoming event",
        "Responses to bot-originated messages go back through the bot, not Telethon",
        "Existing 'telegram' (Telethon) and 'sms' channels continue working unchanged",
        "Unit tests verify channel='telegram_bot' routes through bot API"
      ],
      "priority": 121,
      "passes": true,
      "notes": "Depends on frank_bot-00118 (TelegramBotListener exists). Can be developed in parallel with frank_bot-00119/00120. Ensures bot reply channel is distinct from Telethon."
    },
    {
      "id": "frank_bot-00122",
      "title": "Add DiagnosticsNamespace and SystemNamespace to FrankAPI",
      "acceptanceCriteria": [
        "DiagnosticsNamespace class with full() and health() methods wrapping diagnostics actions via _run_async()",
        "SystemNamespace class with status(), server(), and hello(name) methods wrapping system actions via _run_async()",
        "Both namespaces added to FrankAPI.__init__() as _diagnostics and _system with @property accessors",
        "frank.diagnostics.full() returns comprehensive diagnostics dict",
        "frank.diagnostics.health() returns quick health check dict",
        "frank.system.status() returns orchestration machinery status dict",
        "frank.system.server() returns server uptime info dict",
        "Unit tests verify each method calls the correct underlying action"
      ],
      "priority": 122,
      "passes": true,
      "notes": "No dependencies on new tasks  follows existing namespace pattern in meta/api.py. Blocks frank_bot-00127 (api_learn_action update)."
    },
    {
      "id": "frank_bot-00123",
      "title": "Add JorbsNamespace to FrankAPI",
      "acceptanceCriteria": [
        "JorbsNamespace class with list(status), get(jorb_id, include_messages, message_limit), create(name, plan, contacts, personality, start_immediately), approve(jorb_id, decision), cancel(jorb_id, reason), stats(status), brief(hours), messages(jorb_id, limit, offset)",
        "All methods wrap corresponding actions from actions/jorbs.py via _run_async()",
        "Namespace added to FrankAPI.__init__() as _jorbs with @property accessor",
        "frank.jorbs.list() returns open jorbs by default",
        "frank.jorbs.create(name=..., plan=...) creates a new jorb",
        "frank.jorbs.brief(hours=24) returns activity summary",
        "Unit tests verify each method calls the correct underlying action with correct arguments"
      ],
      "priority": 123,
      "passes": true,
      "notes": "No dependencies on new tasks  follows existing namespace pattern. Blocks frank_bot-00127 (api_learn_action update)."
    },
    {
      "id": "frank_bot-00124",
      "title": "Add ClaudiaNamespace to FrankAPI",
      "acceptanceCriteria": [
        "ClaudiaNamespace class with repos(), chat_create(repo_name, title, message), chat_get(repo_id, chat_id), chat_send(repo_id, chat_id, message), chat_end(repo_id, chat_id), prompts(repo_id), prompt_get(repo_id, prompt_id), prompt_execute(repo_id, prompt_id), queue(repo_id), executions(repo_id, status, limit), execution_get(execution_id)",
        "All methods wrap corresponding actions from actions/claudia.py via _run_async()",
        "Namespace added to FrankAPI.__init__() as _claudia with @property accessor",
        "frank.claudia.repos() returns list of repos",
        "frank.claudia.chat_create('frank_bot', 'Fix bug', message='...') creates a chat session",
        "Unit tests verify each method calls the correct underlying action with correct arguments"
      ],
      "priority": 124,
      "passes": true,
      "notes": "No dependencies on new tasks  follows existing namespace pattern. Blocks frank_bot-00127 (api_learn_action update)."
    },
    {
      "id": "frank_bot-00125",
      "title": "Add StyleNamespace to FrankAPI",
      "acceptanceCriteria": [
        "StyleNamespace class with generate(chat_id, dry_run, before_date) wrapping generate_sean_md_action via _run_async()",
        "Namespace added to FrankAPI.__init__() as _style with @property accessor",
        "frank.style.generate(dry_run=True) returns style generation result dict",
        "Unit tests verify generate() calls the correct underlying action with correct arguments"
      ],
      "priority": 125,
      "passes": true,
      "notes": "No dependencies on new tasks  follows existing namespace pattern. Blocks frank_bot-00127 (api_learn_action update)."
    },
    {
      "id": "frank_bot-00126",
      "title": "Verify Switchboard catch-up behavior with telegram_bot channel",
      "acceptanceCriteria": [
        "Switchboard in agent_runner.py treats channel='telegram_bot' identically to 'telegram' for routing decisions",
        "Unmatched messages from trusted senders create catch-up jorbs that ask for context (might_be_new_jorb=true path)",
        "Review switchboard_system.md prompt  if needed, tweak to be more comfortable saying 'I don't recognize this' rather than force-matching",
        "Integration test: send a message with channel='telegram_bot' from a trusted sender with no matching jorb  verify catch-up jorb is created",
        "Existing Switchboard behavior for 'telegram' and 'sms' channels unchanged"
      ],
      "priority": 126,
      "passes": true,
      "notes": "Depends on frank_bot-00119 (telegram_bot_router creates IncomingEvent with channel='telegram_bot') and frank_bot-00121 (bot reply channel). Validates end-to-end Switchboard behavior for the new channel."
    },
    {
      "id": "frank_bot-00127",
      "title": "Update api_learn_action to document new FrankAPI namespaces",
      "acceptanceCriteria": [
        "api_learn_action in actions/scripts.py documents diagnostics namespace (full, health methods)",
        "api_learn_action documents system namespace (status, server, hello methods)",
        "api_learn_action documents jorbs namespace (list, get, create, approve, cancel, stats, brief, messages methods)",
        "api_learn_action documents claudia namespace (repos, chat_create, chat_get, chat_send, chat_end, prompts, prompt_get, prompt_execute, queue, executions, execution_get methods)",
        "api_learn_action documents style namespace (generate method)",
        "frank.learn() output includes examples and signatures for all new namespaces",
        "Existing namespace documentation unchanged"
      ],
      "priority": 127,
      "passes": true,
      "notes": "Depends on frank_bot-00122, frank_bot-00123, frank_bot-00124, frank_bot-00125 (all new namespaces must exist). Ensures jorb sessions discover new capabilities via frank.learn()."
    },
    {
      "id": "frank_bot-00128",
      "title": "Add timeouts to entrypoint.sh ADB and Vault-dependent commands",
      "acceptanceCriteria": [
        "All adb commands in scripts/entrypoint.sh are wrapped with `timeout` (e.g. `timeout 10 adb ...`)",
        "The maybe_set_android_serial inline Python block has a bounded execution time (timeout wrapper or VAULT_TIMEOUT env var)",
        "The start_gnirehtet function's adb shell, install, and run commands each have explicit timeouts",
        "If any adb or Vault command times out, entrypoint continues to app startup (|| true guards present)",
        "Container starts successfully even when Android device is offline or Vault is unreachable",
        "Existing behavior unchanged when Android device and Vault are both available"
      ],
      "priority": 128,
      "passes": true,
      "notes": "Highest priority fix  a hanging entrypoint blocks the entire container from starting, causing a crash loop. This is the most likely root cause of a production API outage when Vault or Android device is unreachable."
    },
    {
      "id": "frank_bot-00129",
      "title": "Guard app.py module-level get_settings() against Vault failures",
      "acceptanceCriteria": [
        "app.py wraps the module-level `settings = get_settings()` call in a try/except that logs the error and falls back to defaults or env vars",
        "If get_settings() raises due to Vault being unreachable, the app still starts and serves the /health endpoint",
        "A clear error message is logged indicating which secrets failed to load",
        "The health endpoint response indicates degraded mode when secrets failed to load",
        "Existing behavior unchanged when Vault is accessible and all secrets load successfully"
      ],
      "priority": 129,
      "passes": true,
      "notes": "Depends on frank_bot-00128 (entrypoint must not hang first). If entrypoint passes but Vault is still unreachable, an unhandled exception in get_settings() at module level crashes the app before any HTTP server binds."
    },
    {
      "id": "frank_bot-00130",
      "title": "Increase Docker health check start_period and add restart backoff",
      "acceptanceCriteria": [
        "docker-compose.yml health check start_period is increased from 15s to at least 45s to accommodate Vault retries",
        "Health check interval, timeout, and retries are tuned for production reliability (e.g. interval 30s, timeout 10s, retries 3)",
        "Container restart policy prevents tight crash loops (restart: unless-stopped or on-failure with max retries)",
        "Health check test command (curl to /health) is correct and matches the app's actual health endpoint path"
      ],
      "priority": 130,
      "passes": true,
      "notes": "Depends on frank_bot-00128. Even with entrypoint timeouts, Vault retry logic (3 attempts, 10s backoff each) for 23+ secrets can legitimately take 30+ seconds. The health check must accommodate this."
    },
    {
      "id": "frank_bot-00131",
      "title": "Add bounded Vault client timeout and connection failure handling",
      "acceptanceCriteria": [
        "vault_client.py _get_vault_client() has a configurable total timeout (via VAULT_TIMEOUT_SECONDS env var, default 30s) that caps the entire retry sequence",
        "If Vault is unreachable after the timeout, _get_vault_client() returns None instead of retrying indefinitely",
        "get_secret() returns None gracefully when _get_vault_client() returns None (no exception raised)",
        "A warning log is emitted once when Vault connection fails, not per-secret",
        "config.py _load_secrets() handles None returns from get_secret() by falling back to env vars where available",
        "Existing behavior unchanged when Vault is accessible within timeout"
      ],
      "priority": 131,
      "passes": true,
      "notes": "Depends on frank_bot-00129. This is the root defense against Vault outages  without bounded timeouts, any Vault slowdown cascades into app startup failure. The vault client already has MAX_RETRIES=3 and MAX_BACKOFF_SECONDS=10, but there's no overall timeout cap."
    },
    {
      "id": "frank_bot-00132",
      "title": "Harden agent_runner background loop against unhandled exceptions in new code paths",
      "acceptanceCriteria": [
        "The background loop in services/agent_runner.py catches and logs exceptions from new Android task polling logic without crashing the loop",
        "The background loop catches and logs exceptions from new script result payload handling in jorb_session.py without crashing the loop",
        "If the background loop crashes despite error handling, app.py startup_event logs the failure AND sets a flag queryable via /health",
        "The /health endpoint reports background loop status (running vs crashed) in its response",
        "A test verifies that an exception in process_jorb_event does not kill the background loop"
      ],
      "priority": 132,
      "passes": true,
      "notes": "Depends on frank_bot-00129 (app must start first). Recent commits ee26942 and 1567ee0 added ~150 lines to agent_runner.py and jorb_session.py. An unhandled exception in these new paths could silently kill jorb processing while the API appears healthy."
    },
    {
      "id": "frank_bot-00133",
      "title": "Review and fix recent commits for import errors and runtime exceptions",
      "acceptanceCriteria": [
        "git show for each of the 5 most recent commits (fb28472, ee26942, 1567ee0, 65b4317, a2d4537) is reviewed for missing imports, undefined variables, or type errors",
        "Any module-level imports added in recent commits are verified to exist and be importable",
        "Any new code paths that reference config settings or Vault secrets are verified to handle None/missing values",
        "Any identified issues are fixed with minimal code changes",
        "All existing tests still pass after fixes"
      ],
      "priority": 133,
      "passes": true,
      "notes": "Independent of other tasks but lower priority since it's a code review sweep. The most recent commits changed entrypoint behavior (65b4317), agent loop (ee26942, 1567ee0), and added a new prompt (fb28472). Any of these could introduce import-time or runtime errors."
    },
    {
      "id": "frank_bot-00134",
      "title": "Add production startup smoke test and rollback documentation",
      "acceptanceCriteria": [
        "A script or make target exists (e.g. scripts/smoke_test.sh) that verifies the app starts and /health returns 200 within a timeout",
        "The smoke test checks that the background loop is running (via /health response body)",
        "Documentation in the repo (e.g. in scripts/ or ops/) describes how to rollback to a previous git SHA if a deploy breaks production",
        "Rollback docs include: docker commands to revert, how to check logs, and how to verify recovery",
        "The smoke test can be run locally with `docker-compose up` to catch startup failures before deploying"
      ],
      "priority": 134,
      "passes": true,
      "notes": "Depends on frank_bot-00130 (health check must report meaningful status) and frank_bot-00132 (health endpoint must include loop status). This is the prevention layer  catch these issues before they hit production."
    },
    {
      "id": "frank_bot-00135",
      "title": "Fix system-status-card polling refresh layout jank with stale-while-revalidate pattern",
      "acceptanceCriteria": [
        "New @state() property '_refreshing' added to system-status-card.ts",
        "_fetchStatus() sets _loading=true only on initial load (when _status is null and _error is null); subsequent polls set _refreshing=true instead",
        "During background refresh, existing status rows remain rendered  no spinner replaces content",
        "On fetch error when stale data exists, the error is swallowed and last-known-good data stays displayed",
        "_error is only set when no stale data is available (initial load failure)",
        "A subtle inline refresh indicator ( at 0.35 opacity, 0.7em font-size) appears next to 'System Status' header text when _refreshing is true",
        "The manual refresh button is disabled when either _loading or _refreshing is true",
        "No visible layout jank on 60-second polling refresh  card height remains stable",
        "Initial load still shows the full spinner/loading state as before"
      ],
      "priority": 135,
      "passes": true,
      "notes": "No dependencies on other tasks. Single-file change (~20 lines) in web/src/components/system-status-card.ts. Uses Lit's 'nothing' import (should already be available). No new dependencies, no API changes, no structural changes."
    },
    {
      "id": "frank_bot-00136",
      "title": "Persist final screenshot from android task runs to disk",
      "acceptanceCriteria": [
        "In _execute_task_background() in services/android_phone_runner.py, after run completes, decode result.final_screenshot_base64 and write to ./data/screenshots/{task_id}.png",
        "Create ./data/screenshots/ directory if it doesn't exist (os.makedirs with exist_ok=True)",
        "Sanitize task_id before using in file path to prevent path traversal (reject or strip ../ and absolute paths)",
        "Set file permissions to 0o600 on written screenshot files",
        "Include 'final_screenshot_path' key in the result dict written to task storage",
        "Handle None/missing final_screenshot_base64 gracefully (no file written, no path in result)",
        "Do not log base64 screenshot data  log only metadata (file size, path)",
        "Tests in tests/test_android_phone_actions.py verify screenshot file is written when final_screenshot_base64 is present",
        "Tests verify final_screenshot_path is absent when final_screenshot_base64 is None",
        "Tests use a mock 1x1 pixel PNG for final_screenshot_base64"
      ],
      "priority": 136,
      "passes": false,
      "notes": "Foundation task  frank_bot-00137, frank_bot-00138, and frank_bot-00139 all depend on this. Modifies services/android_phone_runner.py and tests/test_android_phone_actions.py."
    },
    {
      "id": "frank_bot-00137",
      "title": "Return final_screenshot_path in task_get_action response",
      "acceptanceCriteria": [
        "task_get_action() in actions/android_phone.py includes 'final_screenshot_path' in its response when present in task storage",
        "Optionally support an 'include_screenshot_base64' parameter that reads the PNG from disk and returns inline base64",
        "If the screenshot file does not exist on disk (deleted or missing), return final_screenshot_path as null rather than erroring",
        "Tests verify task_get response includes final_screenshot_path when available",
        "Tests verify graceful handling when screenshot file is missing from disk"
      ],
      "priority": 137,
      "passes": false,
      "notes": "Depends on frank_bot-00136 (screenshot must be persisted first). Modifies actions/android_phone.py and tests/test_android_phone_actions.py."
    },
    {
      "id": "frank_bot-00138",
      "title": "Add TelegramClient.send_photo() method and telegram_send_photo action",
      "acceptanceCriteria": [
        "New async method send_photo(recipient, photo_path, caption=None) added to services/telegram_client.py",
        "send_photo uses Telethon's client.send_file(recipient, photo_path, caption=caption)",
        "Error handling mirrors send_message()  handles FloodWaitError, UserNotMutualContactError, etc.",
        "Returns TelegramMessageResult (or equivalent) consistent with send_message return type",
        "Path validation: photo_path must be within allowed directories (./data/screenshots/, /tmp/android_screenshot_*)  reject paths outside allowlist",
        "Path validation rejects traversal attacks like ../../etc/passwd",
        "New telegram_send_photo_action(recipient, photo_path, caption) added to actions/telegram_bot.py",
        "Tests mock client.send_file() and verify it is called with correct arguments",
        "Tests verify FloodWaitError handling behavior",
        "Tests verify caption passthrough",
        "Tests verify path validation rejects disallowed paths"
      ],
      "priority": 138,
      "passes": false,
      "notes": "Independent of frank_bot-00136 (no dependency on screenshot persistence), but frank_bot-00139 depends on both this and frank_bot-00136. Modifies services/telegram_client.py, actions/telegram_bot.py, and adds tests."
    },
    {
      "id": "frank_bot-00139",
      "title": "Wire screenshot delivery into task completion pipeline",
      "acceptanceCriteria": [
        "task_do_action() accepts a new 'notify_screenshot' bool parameter (default False)",
        "When notify_screenshot=True and a final screenshot exists, _execute_task_background() sends the screenshot to Sean via TelegramClient.send_photo() after persisting it",
        "Caption includes the task description and completion status (success/failure)",
        "When notify_screenshot=False (default), no photo is sent",
        "Telegram recipient is restricted to Sean's username (allowlist check)",
        "Integration test mocks both android runner and telegram client, verifies photo is sent when notify_screenshot=True",
        "Integration test verifies photo is NOT sent when notify_screenshot=False"
      ],
      "priority": 139,
      "passes": false,
      "notes": "Depends on frank_bot-00136 (screenshot persistence) and frank_bot-00138 (send_photo capability). Modifies services/android_phone_runner.py and actions/android_phone.py."
    },
    {
      "id": "frank_bot-00140",
      "title": "Add per-step screenshot archival with TTL-based cleanup",
      "acceptanceCriteria": [
        "Intermediate StepResult screenshots are saved as ./data/screenshots/{task_id}_step_{n}.png during task execution",
        "task_get_action() supports an 'include_steps' parameter that returns step screenshot paths when True",
        "TTL-based cleanup deletes screenshot files older than 24 hours, following the pattern from android_audit.py 30-day log rotation",
        "Cleanup runs periodically (e.g., on task completion or via a scheduled check)",
        "Step screenshots use the same 0o600 file permissions and path sanitization as final screenshots",
        "Tests verify step screenshots are written during multi-step runs",
        "Tests verify TTL cleanup removes old files and preserves recent ones",
        "Tests verify include_steps=True returns step screenshot paths in task_get response"
      ],
      "priority": 140,
      "passes": false,
      "notes": "Optional enhancement. Depends on frank_bot-00136 (screenshot persistence infrastructure). Modifies services/android_phone_runner.py, actions/android_phone.py, and tests."
    }
  ]
}
