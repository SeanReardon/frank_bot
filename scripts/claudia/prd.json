{
  "project": "frank_bot",
  "version": "0.1.0",
  "branchName": "main",
  "userStories": [
    {
      "id": "frank_bot-00001",
      "title": "Create meta module structure and FrankAPI namespace classes",
      "acceptanceCriteria": [
        "Create meta/ directory with __init__.py, api.py, executor.py, introspection.py files",
        "FrankAPI class exists with namespace properties: calendar, contacts, sms, swarm, ups, time",
        "Each namespace class (CalendarNamespace, ContactsNamespace, etc.) is defined with stub methods",
        "FrankAPI() can be instantiated without errors",
        "Namespace methods are synchronous wrappers that will call existing async actions"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Foundation task - all other meta module tasks depend on this. Focus on structure, not implementation."
    },
    {
      "id": "frank_bot-00002",
      "title": "Implement CalendarNamespace with sync wrappers for existing calendar actions",
      "acceptanceCriteria": [
        "CalendarNamespace.events() calls the existing calendar events action synchronously via asyncio.run()",
        "CalendarNamespace.create() wraps the create event action",
        "CalendarNamespace.list() wraps the list calendars action",
        "Methods accept the same parameters as the underlying actions",
        "Methods return the same dict structure as the underlying actions",
        "Unit tests verify the namespace methods work correctly"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Depends on frank_bot-00001. Template for other namespace implementations."
    },
    {
      "id": "frank_bot-00003",
      "title": "Implement remaining namespace classes (contacts, sms, swarm, ups, time)",
      "acceptanceCriteria": [
        "ContactsNamespace.search(query) wraps contact search action",
        "SMSNamespace.send(recipient, message) wraps SMS send action",
        "SwarmNamespace.checkins() wraps search_checkins_action with all parameters (year, category, with_companion, max_results)",
        "UPSNamespace.status() wraps UPS status action",
        "TimeNamespace.now(timezone=None) wraps time/NTP action",
        "All methods are synchronous using asyncio.run()",
        "Unit tests for each namespace"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Depends on frank_bot-00001 and follows pattern from frank_bot-00002."
    },
    {
      "id": "frank_bot-00004",
      "title": "Implement script storage and parsing utilities",
      "acceptanceCriteria": [
        "Scripts are stored as .py files in ./data/scripts/ directory",
        "Script filenames follow pattern: {ISO8601-timestamp}-{slug}.py",
        "Docstring parser extracts: description (first paragraph), parameters (from Parameters: section), example (from Example: section)",
        "Function to list all scripts with metadata (id, description, parameters, example, created_at)",
        "Function to get a specific script's code by ID",
        "Function to save a new script with slug and code",
        "Unit tests for docstring parsing"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Depends on frank_bot-00001 for module structure. Blocking for frank_bot-00006 and frank_bot-00007."
    },
    {
      "id": "frank_bot-00005",
      "title": "Implement job storage and management",
      "acceptanceCriteria": [
        "Jobs are stored as .json files in ./data/jobs/ directory",
        "Job filenames follow pattern: {ISO8601-timestamp}-{slug}-run.json",
        "Job JSON contains: job_id, script_id, status, params, started_at, completed_at, stdout, stderr, result, error",
        "Status values: pending, running, completed, failed, timeout",
        "Function to create a new job record",
        "Function to update job status and results",
        "Function to list all jobs with status",
        "Function to get a specific job by ID",
        "Unit tests for job CRUD operations"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Depends on frank_bot-00001. Blocking for frank_bot-00008."
    },
    {
      "id": "frank_bot-00006",
      "title": "Implement script executor with timeout and output capture",
      "acceptanceCriteria": [
        "executor.py has function to execute a script's main() function",
        "FrankAPI instance is passed as first argument to main()",
        "Script params are passed as keyword arguments",
        "stdout and stderr are captured during execution",
        "Return value from main() is captured as result",
        "10-minute timeout implemented - script is terminated if exceeded",
        "Timeout results in status='timeout' with clear error message",
        "Exceptions during execution are caught and stored in error field",
        "Execution runs in a background thread to not block",
        "Unit tests with mock scripts verifying output capture, timeout, and error handling"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Depends on frank_bot-00001, frank_bot-00002, frank_bot-00003 (needs working FrankAPI), frank_bot-00004, frank_bot-00005."
    },
    {
      "id": "frank_bot-00007",
      "title": "Implement introspection module for meta documentation generation",
      "acceptanceCriteria": [
        "introspection.py generates Markdown documentation from FrankAPI",
        "Documentation includes: quick start example, all services with method tables",
        "Method tables show: method name, signature with parameters, description",
        "Documentation includes execution instructions (POST /frank/execute workflow)",
        "Generated documentation matches the format specified in the PRD",
        "Unit test verifies documentation structure"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Depends on frank_bot-00001, frank_bot-00002, frank_bot-00003 (needs complete FrankAPI to document)."
    },
    {
      "id": "frank_bot-00008",
      "title": "Add GET /frank/meta and GET /frank/scripts endpoints",
      "acceptanceCriteria": [
        "GET /frank/meta returns Markdown documentation from introspection module",
        "GET /frank/scripts returns JSON list of all saved scripts with metadata",
        "GET /frank/scripts/{id} returns a specific script's code",
        "Endpoints follow existing route patterns in server/routes.py",
        "Endpoints are protected by existing API key auth",
        "Integration tests for each endpoint"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Depends on frank_bot-00004, frank_bot-00007."
    },
    {
      "id": "frank_bot-00009",
      "title": "Add POST /frank/execute endpoint",
      "acceptanceCriteria": [
        "POST /frank/execute accepts JSON with: slug, code, params (for new script)",
        "POST /frank/execute accepts JSON with: script_id, params (for existing script)",
        "Endpoint saves new script if code provided",
        "Endpoint creates job record and starts execution in background",
        "Returns immediately with job_id and status='running'",
        "Multiple concurrent executions are supported",
        "Endpoint protected by existing API key auth",
        "Integration tests for both new script and existing script execution"
      ],
      "priority": 9,
      "passes": true,
      "notes": "Depends on frank_bot-00004, frank_bot-00005, frank_bot-00006."
    },
    {
      "id": "frank_bot-00010",
      "title": "Add GET /frank/jobs endpoints",
      "acceptanceCriteria": [
        "GET /frank/jobs returns JSON list of all job runs with status",
        "GET /frank/jobs/{id} returns full job details: job_id, script_id, status, params, started_at, completed_at, stdout, stderr, result, error",
        "Completed jobs include the result from main()",
        "Failed/timeout jobs include error message",
        "Endpoints protected by existing API key auth",
        "Integration tests for job listing and retrieval"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Depends on frank_bot-00005, frank_bot-00009 (needs jobs to exist)."
    },
    {
      "id": "frank_bot-00011",
      "title": "Update OpenAPI spec with new meta endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes /frank/meta endpoint with response schema",
        "openapi/spec.json includes /frank/scripts and /frank/scripts/{id} endpoints",
        "openapi/spec.json includes /frank/execute endpoint with request/response schemas",
        "openapi/spec.json includes /frank/jobs and /frank/jobs/{id} endpoints",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json",
        "Request/response schemas accurately reflect the API"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Depends on frank_bot-00008, frank_bot-00009, frank_bot-00010. Can be done in parallel with integration testing."
    },
    {
      "id": "frank_bot-00012",
      "title": "Update instructions_for_chatgpt.txt with script execution guidance",
      "acceptanceCriteria": [
        "Instructions explain when to use execute (pagination, filtering, aggregation, combining data sources)",
        "Instructions describe the workflow: meta -> scripts -> execute -> jobs -> present",
        "Instructions emphasize execute is for getting data, not presenting it",
        "Instructions mention checking /frank/scripts for reusable scripts",
        "Instructions include example use case (hotels in SF)",
        "Instructions reference /frank/meta for understanding capabilities"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Can be done after API implementation is complete. No hard dependencies but should reflect final API."
    },
    {
      "id": "frank_bot-00013",
      "title": "Ensure data volume is mounted in Docker configuration",
      "acceptanceCriteria": [
        "docker-compose.yml mounts ./data:/app/data volume",
        "Container can write to ./data/scripts/ and ./data/jobs/ directories",
        "Data persists across container restarts",
        "README documents the data directory structure"
      ],
      "priority": 13,
      "passes": true,
      "notes": "Infrastructure task. Can be done early but testing requires the endpoints to exist."
    },
    {
      "id": "frank_bot-00014",
      "title": "Add Telethon dependency and Telegram configuration settings",
      "acceptanceCriteria": [
        "telethon package added to pyproject.toml dependencies",
        "poetry.lock updated with telethon and its dependencies",
        "config.py updated with new settings: TELEGRAM_API_ID, TELEGRAM_API_HASH, TELEGRAM_PHONE, TELEGRAM_SESSION_NAME",
        "TELEGRAM_SESSION_NAME defaults to 'frank_bot' if not set",
        ".env.example updated with Telegram environment variable placeholders",
        ".gitignore updated to ignore *.session files (Telethon session files)"
      ],
      "priority": 14,
      "passes": true,
      "notes": "Foundation task for Telegram integration - all other Telegram tasks depend on this."
    },
    {
      "id": "frank_bot-00015",
      "title": "Create TelegramClientService with Telethon wrapper",
      "acceptanceCriteria": [
        "services/telegram_client.py file created following existing service patterns",
        "TelegramClientService class initialized with API credentials from config",
        "is_configured property returns True only when API_ID, API_HASH, and PHONE are set",
        "Session file stored in configurable location (default: project root)",
        "Async connect() method initializes and starts the Telethon client",
        "Async disconnect() method cleanly shuts down the client",
        "Service handles missing credentials gracefully with clear error messages"
      ],
      "priority": 15,
      "passes": true,
      "notes": "Depends on frank_bot-00014. Core service wrapper - blocking for frank_bot-00016."
    },
    {
      "id": "frank_bot-00016",
      "title": "Implement TelegramClientService message sending and retrieval methods",
      "acceptanceCriteria": [
        "send_message(recipient, text) method sends message to user/bot by username or phone",
        "get_messages(chat_id, limit) method retrieves recent messages from a chat",
        "get_dialogs(limit) method lists recent conversations with metadata",
        "mark_read(chat_id) method marks messages as read in a chat",
        "All methods are async and properly await Telethon operations",
        "Methods return structured result objects (dataclasses) similar to SMSResult pattern",
        "Error handling for: recipient not found, rate limiting, session invalidation",
        "Unit tests with mocked Telethon client verify method behavior"
      ],
      "priority": 16,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Implements the core Telegram functionality."
    },
    {
      "id": "frank_bot-00017",
      "title": "Create Telegram action handlers",
      "acceptanceCriteria": [
        "actions/telegram.py file created following existing action patterns",
        "send_telegram_message(arguments) action sends message with recipient and text parameters",
        "get_telegram_messages(arguments) action retrieves messages with chat and limit parameters",
        "list_telegram_chats(arguments) action lists recent conversations with limit parameter",
        "Actions follow signature: async def action_name(arguments: dict[str, Any] | None = None) -> dict[str, Any]",
        "Actions return structured dicts with success status and relevant data",
        "Actions raise ValueError with clear messages on validation failures",
        "Unit tests verify action behavior with mocked TelegramClientService"
      ],
      "priority": 17,
      "passes": true,
      "notes": "Depends on frank_bot-00016. Action layer between routes and service."
    },
    {
      "id": "frank_bot-00018",
      "title": "Add Telegram routes to server",
      "acceptanceCriteria": [
        "GET /telegram/send route added to server/routes.py",
        "GET /telegram/messages route added to server/routes.py",
        "GET /telegram/chats route added to server/routes.py",
        "Routes use _build_responder wrapper pattern like existing routes",
        "Routes accept query parameters matching action arguments",
        "Routes protected by existing API key authentication",
        "Integration tests verify routes call correct actions"
      ],
      "priority": 18,
      "passes": true,
      "notes": "Depends on frank_bot-00017. Exposes Telegram functionality via HTTP."
    },
    {
      "id": "frank_bot-00019",
      "title": "Update OpenAPI spec with Telegram endpoints",
      "acceptanceCriteria": [
        "openapi/spec.json includes GET /telegram/send endpoint with query parameters and response schema",
        "openapi/spec.json includes GET /telegram/messages endpoint with query parameters and response schema",
        "openapi/spec.json includes GET /telegram/chats endpoint with query parameters and response schema",
        "Schemas accurately describe request parameters and response structures",
        "Spec passes linting with npx @redocly/cli lint openapi/spec.json",
        "Endpoint descriptions explain the user account context (not a bot)"
      ],
      "priority": 19,
      "passes": true,
      "notes": "Depends on frank_bot-00018. Documents API for ChatGPT/OpenAI integration."
    },
    {
      "id": "frank_bot-00020",
      "title": "Create Telegram session setup script",
      "acceptanceCriteria": [
        "scripts/setup_telegram_session.py created for interactive first-time auth",
        "Script prompts for phone number if not in environment",
        "Script handles Telegram verification code input (SMS or app)",
        "Script creates .session file upon successful authentication",
        "Script provides clear instructions and error messages",
        "Script can be run standalone: poetry run python scripts/setup_telegram_session.py",
        "README updated with Telegram setup instructions referencing this script"
      ],
      "priority": 20,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Required for first-time Telegram authentication in server/Docker context."
    },
    {
      "id": "frank_bot-00021",
      "title": "Add TelegramNamespace to FrankAPI for script execution",
      "acceptanceCriteria": [
        "TelegramNamespace class added to meta/api.py",
        "TelegramNamespace.send(recipient, text) wraps send_telegram_message action",
        "TelegramNamespace.messages(chat, limit) wraps get_telegram_messages action",
        "TelegramNamespace.chats(limit) wraps list_telegram_chats action",
        "FrankAPI.telegram property returns TelegramNamespace instance",
        "Methods are synchronous wrappers using asyncio.run() pattern",
        "Unit tests verify namespace methods work correctly",
        "Introspection module updated to include TelegramNamespace in documentation"
      ],
      "priority": 21,
      "passes": true,
      "notes": "Depends on frank_bot-00017. Enables Telegram access in meta script execution."
    },
    {
      "id": "frank_bot-00022",
      "title": "Update TelegramClientService to use DATA_DIR for session file location",
      "acceptanceCriteria": [
        "services/telegram_client.py updated to read DATA_DIR environment variable",
        "Session file path constructed as: os.path.join(os.getenv('DATA_DIR', '.'), settings.telegram_session_name)",
        "Session file is created in /app/data/ when DATA_DIR=/app/data",
        "Existing session files in project root still work when DATA_DIR is not set",
        "Unit test verifies session path construction logic"
      ],
      "priority": 22,
      "passes": true,
      "notes": "Depends on frank_bot-00015. Required for sharing session between API and web containers via mounted volume."
    },
    {
      "id": "frank_bot-00023",
      "title": "Add GET /telegram/status endpoint",
      "acceptanceCriteria": [
        "GET /telegram/status route added to server/routes.py",
        "Returns JSON: { status: 'not_configured' | 'needs_auth' | 'connected', account?: { name, username, phone } }",
        "Status 'not_configured' when TELEGRAM_API_ID, TELEGRAM_API_HASH, or TELEGRAM_PHONE env vars missing",
        "Status 'needs_auth' when env vars present but session file missing or unauthorized",
        "Status 'connected' when session is authorized, includes account info from get_me()",
        "Endpoint does NOT require Stytch auth (public status check)",
        "Integration test verifies all three status states"
      ],
      "priority": 23,
      "passes": true,
      "notes": "Depends on frank_bot-00015, frank_bot-00022. Foundation endpoint for web dashboard Telegram card."
    },
    {
      "id": "frank_bot-00024",
      "title": "Add Stytch session validation middleware for protected routes",
      "acceptanceCriteria": [
        "New middleware function validates stytch_session_token cookie",
        "Middleware calls Stytch API to verify session is valid",
        "STYTCH_PROJECT_ID and STYTCH_SECRET environment variables added to config",
        "Invalid/missing session returns 401 Unauthorized JSON response",
        "Middleware can be applied to specific routes via decorator or route configuration",
        "Unit tests with mocked Stytch API verify validation logic"
      ],
      "priority": 24,
      "passes": true,
      "notes": "No direct dependencies. Required for protecting Telegram auth endpoints. Reference ~/dev/contrived-site/ for Stytch integration patterns."
    },
    {
      "id": "frank_bot-00025",
      "title": "Add POST /telegram/auth/start endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/start route added to server/routes.py",
        "Accepts JSON body: { phone?: string } (optional, uses TELEGRAM_PHONE env var if not provided)",
        "Returns JSON: { status: 'code_sent' | 'already_authorized' | 'error', phoneCodeHash?: string }",
        "Calls Telethon send_code_request() to trigger verification code",
        "Returns phoneCodeHash needed for verification step",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies code sending flow (mocked Telegram API)"
      ],
      "priority": 25,
      "passes": true,
      "notes": "Depends on frank_bot-00015, frank_bot-00024. First step in web-based Telegram auth flow."
    },
    {
      "id": "frank_bot-00026",
      "title": "Add POST /telegram/auth/verify endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/verify route added to server/routes.py",
        "Accepts JSON body: { code: string, phoneCodeHash: string }",
        "Returns JSON: { status: 'success' | 'invalid_code' | 'needs_2fa' | 'error' }",
        "Calls Telethon sign_in() with verification code",
        "Returns 'needs_2fa' if account has two-factor authentication enabled",
        "On success, session file is created/updated",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies verification flow including 2FA detection"
      ],
      "priority": 26,
      "passes": true,
      "notes": "Depends on frank_bot-00025. Second step in web-based Telegram auth flow."
    },
    {
      "id": "frank_bot-00027",
      "title": "Add POST /telegram/auth/2fa endpoint",
      "acceptanceCriteria": [
        "POST /telegram/auth/2fa route added to server/routes.py",
        "Accepts JSON body: { password: string }",
        "Returns JSON: { status: 'success' | 'invalid_password' | 'error' }",
        "Calls Telethon sign_in() with 2FA password",
        "On success, session file is created/updated",
        "Endpoint protected by Stytch session validation middleware",
        "Integration test verifies 2FA completion flow"
      ],
      "priority": 27,
      "passes": true,
      "notes": "Depends on frank_bot-00026. Final step in web-based Telegram auth flow for 2FA accounts."
    },
    {
      "id": "frank_bot-00028",
      "title": "Add GET /telegram/test endpoint",
      "acceptanceCriteria": [
        "GET /telegram/test route added to server/routes.py",
        "Returns JSON: { connected: boolean, dialogs?: [first 3 chats], error?: string }",
        "When connected, fetches first 3 dialogs via get_dialogs(limit=3)",
        "When not connected, returns connected: false with error message",
        "Endpoint does NOT require Stytch auth (allows testing from ChatGPT)",
        "Integration test verifies connected and disconnected states"
      ],
      "priority": 28,
      "passes": true,
      "notes": "Depends on frank_bot-00016, frank_bot-00023. Provides connection test functionality for dashboard."
    },
    {
      "id": "frank_bot-00029",
      "title": "Create web/ directory with Vite + TypeScript + Lit project scaffold",
      "acceptanceCriteria": [
        "web/ directory created with package.json including: lit 3.x, vite 5.x, typescript",
        "vite.config.ts configured with dual build mode (dev SPA + library IIFE bundle)",
        "tsconfig.json with strict mode, decorators enabled, ES2020 target",
        "web/src/ directory structure: components/, lib/, styles/",
        "web/index.html for dev preview page",
        "npm run dev starts Vite dev server with API proxy to http://frank-bot:8000",
        "npm run build creates dist/ for dev and dist-lib/bundle.js for embedding"
      ],
      "priority": 29,
      "passes": true,
      "notes": "No dependencies. Foundation for all frontend tasks. Follow ~/dev/claudia/web/ patterns."
    },
    {
      "id": "frank_bot-00030",
      "title": "Create web/Dockerfile with multi-stage build",
      "acceptanceCriteria": [
        "web/Dockerfile created with two stages: node:20-alpine builder, nginx:alpine production",
        "Builder stage runs npm ci and npm run build:lib",
        "Production stage copies dist-lib/bundle.js and nginx.conf",
        "Health check configured for container",
        "Image builds successfully: docker build -t frank_bot-web ./web",
        "Container serves bundle.js at /bundle.js"
      ],
      "priority": 30,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required for containerized deployment."
    },
    {
      "id": "frank_bot-00031",
      "title": "Create web/nginx.conf with API proxy and static file serving",
      "acceptanceCriteria": [
        "web/nginx.conf created with routing rules",
        "/api/* requests proxied to http://frank-bot:8000/* (strip /api prefix)",
        "/health returns 200 for container health checks",
        "/* serves static files with SPA fallback (try_files $uri $uri/ /index.html)",
        "/bundle.js served with CORS headers for contrived.com embedding",
        "Gzip compression enabled for text, JSON, JS",
        "Static assets (JS/CSS/images) served with long cache headers"
      ],
      "priority": 31,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required for frank_bot-00030 Dockerfile."
    },
    {
      "id": "frank_bot-00032",
      "title": "Create API client module (web/src/lib/api.ts)",
      "acceptanceCriteria": [
        "web/src/lib/api.ts created following ~/dev/claudia/web/src/api.ts pattern",
        "configure({ apiBase, sessionToken }) function for initialization",
        "request<T>(path, options) wrapper with auth header and error handling",
        "AuthError class for 401/403 responses",
        "getTelegramStatus() function calls GET /telegram/status",
        "startTelegramAuth(phone?) function calls POST /telegram/auth/start",
        "verifyTelegramCode(code, phoneCodeHash) function calls POST /telegram/auth/verify",
        "submitTelegram2FA(password) function calls POST /telegram/auth/2fa",
        "testTelegramConnection() function calls GET /telegram/test",
        "getScripts() function calls GET /frank/scripts",
        "getJobs() function calls GET /frank/jobs"
      ],
      "priority": 32,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Required before any frontend components can be built."
    },
    {
      "id": "frank_bot-00033",
      "title": "Create CSS tokens file (web/src/styles/tokens.css)",
      "acceptanceCriteria": [
        "web/src/styles/tokens.css created with CSS custom property fallbacks",
        "Fallback values for: --color-bg, --color-text, --color-primary, --color-border, --color-success, --color-error",
        "Fallback values for: --font-family, --font-size-base, --spacing-unit, --border-radius",
        "Values work standalone for dev mode and inherit from contrived-site when embedded",
        "Tokens imported in main dashboard component"
      ],
      "priority": 33,
      "passes": true,
      "notes": "Depends on frank_bot-00029. Provides theming foundation for components."
    },
    {
      "id": "frank_bot-00034",
      "title": "Create main dashboard component (frank-bot-dashboard.ts)",
      "acceptanceCriteria": [
        "web/src/frank-bot-dashboard.ts created as Lit web component",
        "@customElement('frank-bot-dashboard') decorator applied",
        "Accepts attributes: session-token (optional), api-base (default: /api)",
        "Reads stytch_session_token from cookie if session-token attribute not provided",
        "Initializes API client on connectedCallback()",
        "Renders container with slots for child cards (telegram-card, scripts-card, jobs-card)",
        "Includes activity-tracker-lite.js script for session keepalive",
        "Component renders successfully in dev mode"
      ],
      "priority": 34,
      "passes": true,
      "notes": "Depends on frank_bot-00032, frank_bot-00033. Entry point component for dashboard."
    },
    {
      "id": "frank_bot-00035",
      "title": "Create Telegram card component (telegram-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/telegram-card.ts created as Lit web component",
        "@customElement('telegram-card') decorator applied",
        "Fetches status from /telegram/status on mount",
        "Displays 'not_configured' state with message about missing env vars",
        "Displays 'needs_auth' state with Connect Telegram button",
        "Displays 'connected' state with account info (name, username, phone)",
        "Connected state includes Test Connection button that calls /telegram/test",
        "Uses CSS custom properties from tokens.css for styling"
      ],
      "priority": 35,
      "passes": true,
      "notes": "Depends on frank_bot-00023, frank_bot-00032, frank_bot-00034. Basic status display without auth wizard."
    },
    {
      "id": "frank_bot-00036",
      "title": "Add Telegram auth wizard to telegram-card component",
      "acceptanceCriteria": [
        "telegram-card.ts extended with multi-step auth wizard",
        "Step 1: Click Connect Telegram -> calls /telegram/auth/start -> shows code input",
        "Step 2: Enter verification code -> calls /telegram/auth/verify",
        "Step 3 (conditional): If needs_2fa, show password input -> calls /telegram/auth/2fa",
        "Success state transitions to 'connected' display",
        "Error states show clear messages and allow retry",
        "Loading states shown during API calls",
        "phoneCodeHash maintained in component state between steps"
      ],
      "priority": 36,
      "passes": true,
      "notes": "Depends on frank_bot-00025, frank_bot-00026, frank_bot-00027, frank_bot-00035. Completes Telegram setup wizard."
    },
    {
      "id": "frank_bot-00037",
      "title": "Create scripts card component (scripts-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/scripts-card.ts created as Lit web component",
        "@customElement('scripts-card') decorator applied",
        "Fetches scripts list from GET /frank/scripts on mount",
        "Displays list of scripts with: name, description, execution count, last run time",
        "Empty state shown when no scripts exist",
        "Click on script shows expanded details (full description, example code)",
        "Refresh button to reload scripts list",
        "Uses CSS custom properties from tokens.css for styling"
      ],
      "priority": 37,
      "passes": true,
      "notes": "Depends on frank_bot-00008, frank_bot-00032, frank_bot-00034. Displays meta scripts."
    },
    {
      "id": "frank_bot-00038",
      "title": "Create jobs card component (jobs-card.ts)",
      "acceptanceCriteria": [
        "web/src/components/jobs-card.ts created as Lit web component",
        "@customElement('jobs-card') decorator applied",
        "Fetches jobs list from GET /frank/jobs on mount",
        "Displays list of jobs with: script name, status badge, started_at, duration",
        "Status badges color-coded: pending (gray), running (blue), completed (green), failed (red)",
        "Empty state shown when no jobs exist",
        "Click on job shows expanded details (stdout, stderr, result/error)",
        "Filter dropdown to filter by status (all, pending, running, completed, failed)",
        "Auto-refresh toggle for polling running jobs"
      ],
      "priority": 38,
      "passes": true,
      "notes": "Depends on frank_bot-00010, frank_bot-00032, frank_bot-00034. Displays job executions."
    },
    {
      "id": "frank_bot-00039",
      "title": "Add CI/CD workflow for web container build and push",
      "acceptanceCriteria": [
        ".github/workflows/build_and_push.yml updated to include web container build",
        "Workflow builds ./web/Dockerfile",
        "Image pushed to ghcr.io/seanreardon/frank_bot-web:latest",
        "Build triggered on changes to web/ directory",
        "Build uses same authentication/registry patterns as existing frank_bot image",
        "Workflow passes on PR and main branch"
      ],
      "priority": 39,
      "passes": true,
      "notes": "Depends on frank_bot-00030. Final deployment step for web dashboard. Web container build job added to workflow."
    },
    {
      "id": "frank_bot-00040",
      "title": "Create SMSStorage service for file-based message persistence",
      "acceptanceCriteria": [
        "services/sms_storage.py created with SMSStorage class",
        "SMSMessage Pydantic model created matching schemas/sms.schema.json",
        "store_message(message: SMSMessage) writes JSON to ./data/sms/{localNumber}/ directory",
        "Filename pattern: {ISO8601-timestamp}-{contact-name-or-phone}.json (using - instead of : for filesystem)",
        "Contact name sanitized for filesystem (replace <>/:\"/\\|?* with _)",
        "If no contact, use phone number with + as filename identifier",
        "get_recent_messages(local_number, remote_number, contact_name, limit) retrieves and filters stored messages",
        "Messages sorted by timestamp descending (most recent first)",
        "Unit tests verify storage, retrieval, and filename generation"
      ],
      "priority": 40,
      "passes": true,
      "notes": "Foundation for SMS storage. Blocking for frank_bot-00041, frank_bot-00042, frank_bot-00046."
    },
    {
      "id": "frank_bot-00041",
      "title": "Add MMS attachment download and storage to SMSStorage",
      "acceptanceCriteria": [
        "SMSStorage._download_attachment(url, filepath) downloads media from Telnyx URL",
        "Uses httpx async client with proper timeout handling",
        "Attachment filenames follow pattern: {timestamp}-{contact}-attachment-{n}.{ext}",
        "Extension determined from MIME type using mimetypes.guess_extension()",
        "Falls back to .bin extension if MIME type unknown",
        "store_message() downloads attachments before writing JSON",
        "Attachment.filename field updated with local filename after download",
        "Unit tests with mocked HTTP responses verify download logic"
      ],
      "priority": 41,
      "passes": true,
      "notes": "Depends on frank_bot-00040. Extends SMSStorage to handle MMS attachments."
    },
    {
      "id": "frank_bot-00042",
      "title": "Create ContactLookup service for phone-to-contact reverse lookup",
      "acceptanceCriteria": [
        "services/contact_lookup.py created with ContactLookup class",
        "lookup(phone_number: str) searches Google Contacts for matching phone",
        "Phone numbers normalized for comparison (strip spaces, dashes, handle country codes)",
        "Returns Contact dataclass with name and googleContactId, or None if not found",
        "In-memory cache prevents repeated API calls for same number",
        "Uses existing GoogleContactsService for API access",
        "Unit tests with mocked contacts verify lookup and caching behavior"
      ],
      "priority": 42,
      "passes": true,
      "notes": "Depends on existing GoogleContactsService. Blocking for frank_bot-00044."
    },
    {
      "id": "frank_bot-00043",
      "title": "Create TelegramBot service for notification messages",
      "acceptanceCriteria": [
        "services/telegram_bot.py created with TelegramBot class (separate from Telethon user client)",
        "Uses Telegram Bot API via httpx (not Telethon)",
        "TelegramBot(token, chat_id) constructor with credentials",
        "send_notification(text, parse_mode='HTML') sends message to configured chat",
        "notify_unknown_sms(from_number, message, attachments) formats and sends unknown sender alert",
        "notify_spam(from_number, message, reason) formats and sends spam alert",
        "get_telegram_bot_credentials() added to services/vault_client.py to fetch from Vault",
        "config.py updated with TELEGRAM_BOT_TOKEN and TELEGRAM_BOT_CHAT_ID settings",
        "Unit tests with mocked HTTP verify notification formatting"
      ],
      "priority": 43,
      "passes": true,
      "notes": "No dependencies. Uses Bot API not Telethon. Blocking for frank_bot-00045."
    },
    {
      "id": "frank_bot-00044",
      "title": "Create SMS webhook endpoint for inbound Telnyx messages",
      "acceptanceCriteria": [
        "server/sms_webhook.py created with sms_webhook_handler(request) async function",
        "Route POST /webhook/sms added to server/routes.py (no API key required)",
        "Handler extracts event_type and direction from Telnyx payload",
        "Skips non-inbound messages (outbound confirmations, delivery receipts)",
        "For inbound messages: parses from_number, to_number, text, media array, telnyx_id",
        "Calls ContactLookup to resolve sender to contact",
        "Creates SMSMessage object with all fields populated",
        "Calls SMSStorage.store_message() to persist immediately",
        "Returns JSON {status: 'processed'} or {status: 'skipped', reason: '...'}"
      ],
      "priority": 44,
      "passes": true,
      "notes": "Depends on frank_bot-00040, frank_bot-00042. Core webhook handler without compliance or routing logic."
    },
    {
      "id": "frank_bot-00045",
      "title": "Add STOP/HELP compliance handling for unknown contacts",
      "acceptanceCriteria": [
        "sms_webhook_handler checks for compliance keywords ONLY when contact is None",
        "STOP command: records opt-out (could be simple file or database), sends confirmation SMS",
        "HELP command: sends help message with contact info via Telnyx SMS",
        "START/YES/OPTIN/SUBSCRIBE commands: records opt-in, sends confirmation",
        "Known contacts bypass all compliance handling (proceed to normal processing)",
        "Compliance messages stored with classification='compliance'",
        "opt_outs.json file in ./data/ tracks opted-out phone numbers",
        "Unit tests verify compliance flows for unknown contacts"
      ],
      "priority": 45,
      "passes": true,
      "notes": "Depends on frank_bot-00044. Extends webhook with regulatory compliance for unknown senders."
    },
    {
      "id": "frank_bot-00046",
      "title": "Add Telegram Bot notifications for unknown SMS senders",
      "acceptanceCriteria": [
        "sms_webhook_handler sends Telegram notification after storing unknown sender messages",
        "Notification includes: from_number, message preview (truncated at 500 chars), attachment count",
        "Uses TelegramBot.notify_unknown_sms() method",
        "Notification only sent when contact is None and message is not compliance-related",
        "Gracefully handles Telegram API failures (log error, don't fail webhook)",
        "Classification set to 'unknown' for messages triggering notification",
        "Integration test verifies notification is sent for unknown senders"
      ],
      "priority": 46,
      "passes": true,
      "notes": "Depends on frank_bot-00043, frank_bot-00044. Adds notification flow for unknown contacts."
    },
    {
      "id": "frank_bot-00047",
      "title": "Update outbound SMS to also store messages",
      "acceptanceCriteria": [
        "services/telnyx_sms.py send_sms() modified to store outbound messages",
        "After successful send, creates SMSMessage with direction='outbound'",
        "Calls ContactLookup to resolve recipient to contact (for consistent naming)",
        "Sets processed=True for outbound messages (already 'processed')",
        "Stores via SMSStorage.store_message()",
        "Existing send_sms behavior unchanged (still returns SMSResult)",
        "Unit tests verify outbound messages are stored alongside inbound"
      ],
      "priority": 47,
      "passes": true,
      "notes": "Depends on frank_bot-00040, frank_bot-00042. Creates complete conversation history."
    },
    {
      "id": "frank_bot-00048",
      "title": "Add ChatGPT action and route for reading SMS messages",
      "acceptanceCriteria": [
        "actions/sms.py created with get_sms_messages_action(arguments) function",
        "Accepts parameters: limit (default 50, max 100), contact (fuzzy match), phone, direction",
        "Returns JSON with count and messages array",
        "Each message includes: timestamp, direction, contact name (if known), phone, preview (100 chars), hasAttachments, jorbId",
        "GET /actions/sms/messages route added to server/routes.py",
        "Route protected by existing API key authentication",
        "OpenAPI spec updated with /actions/sms/messages endpoint definition",
        "Integration tests verify filtering by contact, phone, and direction"
      ],
      "priority": 48,
      "passes": true,
      "notes": "Depends on frank_bot-00040. Exposes SMS history to ChatGPT."
    },
    {
      "id": "frank_bot-00049",
      "title": "Create web dashboard Telegram Bot status card",
      "acceptanceCriteria": [
        "GET /telegram-bot/status endpoint added returning {configured: boolean, chatId?: string}",
        "Checks if TELEGRAM_BOT_TOKEN and TELEGRAM_BOT_CHAT_ID are set",
        "POST /telegram-bot/test endpoint sends test notification via TelegramBot",
        "Returns {success: boolean, error?: string}",
        "web/src/components/telegram-bot-card.ts created as Lit component",
        "Card displays configuration status (configured/not configured)",
        "Test Connection button calls POST /telegram-bot/test and shows result",
        "Uses existing dashboard CSS tokens for styling"
      ],
      "priority": 49,
      "passes": true,
      "notes": "Depends on frank_bot-00043, frank_bot-00034. Optional web UI for Telegram bot status."
    },
    {
      "id": "frank_bot-00050",
      "title": "Add SMS messages card to web dashboard",
      "acceptanceCriteria": [
        "web/src/lib/api.ts extended with getSmsMessages(options) function",
        "web/src/components/sms-card.ts created as Lit component",
        "Card fetches and displays recent SMS messages from GET /actions/sms/messages",
        "Displays messages grouped by conversation (remote number)",
        "Shows contact name if known, phone number otherwise",
        "Inbound/outbound messages visually distinguished (alignment or color)",
        "MMS attachment indicator shown when hasAttachments is true",
        "Refresh button to reload messages",
        "Filter by contact/phone input field"
      ],
      "priority": 50,
      "passes": true,
      "notes": "Depends on frank_bot-00048, frank_bot-00034. Displays SMS history in web UI."
    }
  ]
}
